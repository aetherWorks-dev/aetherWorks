#import	"TextureEdit.h"
#import	"TexturePalette.h"
#import	"DoomProject.h"
#import	"Wadfile.h"
#import	<ctype.h>
#import	"lbmfunctions.h"

id	textureEdit_i;
id	texturePatches;

@implementation TextureEdit

- init
{
	window_i = NULL;
	textureEdit_i = self;
	currentTexture = -1; 
	oldx = oldy = 0;
	return self;
}

- saveFrame
{
	if (window_i)
		[window_i	saveFrameUsingName:"TextureEditor"];
	if (createTexture_i)
		[createTexture_i	saveFrameUsingName:"CTexturePanel"];
	return self;
}

//
// user wants to activate the Texture Editor. If it hasn't been used yet,
// init everything, otherwise just pull it back up.
//
- menuTarget:sender
{
	if (![doomproject_i loaded])
	{
		NXRunAlertPanel("Oops!",
						"There must be a project loaded before you even\n"
						"THINK about editing textures!",
						"OK",NULL,NULL,NULL);
		return self;
	}
	
	if (!window_i)
	{
		NXSize	s;
		NXRect	dvf;
		NXPoint	startPoint;
		int		ns, i;
		
		[NXApp 
			loadNibSection:	"TextureEdit.nib"
			owner:			self
			withNames:		NO
		];
		
		[window_i	setDelegate:self];
		[self		computePatchDocView:&dvf];
		[texturePatchView_i	sizeTo:dvf.size.width :dvf.size.height];

		//
		// start patches at top
		//
		#if 0
		[texturePatchScrollView_i	getContentSize:&s];
		startPoint.x = 0;
		startPoint.y = dvf.size.height - s.height;
		[texturePatchView_i		scrollPoint:&startPoint];
		#endif
		[self	setSelectedPatch:0];

		//
		// start texture editor at top
		//
		[textureView_i		getFrame:&dvf];
		[scrollView_i		getContentSize:&s];
		startPoint.y = dvf.size.height - s.height;
		[textureView_i		scrollPoint:&startPoint];
	
		selectedTexturePatches = [[Storage	alloc]
							initCount:		0
							elementSize:	sizeof(int)
							description:	NULL];
		
		[window_i	setFrameUsingName:"TextureEditor"];
		[createTexture_i	setFrameUsingName:"CTexturePanel"];
		
		[splitView_i	addSubview:topView_i];
		[splitView_i	addSubview:botView_i];
		[splitView_i	setDelegate:self];

		//
		//	Create more radio buttons if more texture sets exist
		//
		ns = [self	numSets ];
		for (i = 0; i < ns; i++)
			[self	createNewSet:NULL ];
	}
	
	[self	newSelection:currentTexture];
	[window_i	makeKeyAndOrderFront:NULL];
	return self;
}

//
//	Delegate method called by NXSplitView (splitView_i)
//
- splitView:sender 
	getMinY:(NXCoord *)minY 
	maxY:(NXCoord *)maxY 
	ofSubviewAt:(int)offset
{
	if (*minY < 100)
		*minY = 100;
	if (*maxY > 350)
		*maxY = 350;
	[sender	adjustSubviews];
	return self;
}

- (int)numSets
{
	int	i, max;
	
	max = 0;
	for (i = 0; i < numtextures; i++)
		if (textures[i].WADindex > max)
			max = textures[i].WADindex;
	return max;
}

- windowDidMiniaturize:sender
{
	[sender	setMiniwindowIcon:"DoomEd"];
	[sender	setMiniwindowTitle:"TextureEdit"];
	return self;
}


//=====================================================
//
//	TEXTURE PATCH STUFF
//
//=====================================================

//
// sort the "selected patches" list so pasting looks correct
//
- sortSelectedList
{
	int	i,max,found,*e1,*e2,temp;
	
	max = [selectedTexturePatches	count] - 1;
	do
	{
		found = 0;
		for (i = 0;i < max;i++)
		{
			e1 = [selectedTexturePatches elementAt:i];
			e2 = [selectedTexturePatches elementAt:i+1];
			if (*e2 < *e1)
			{
				temp = *e1;
				*e1 = *e2;
				*e2 = temp;
				found = 1;
			}
		}
	} while(found);
	return self;
}

//
// copy patches
//
- copy:sender
{
	int	i,max;

	if ([copyList	count])
		[copyList	empty];
	
	copyList = [[Storage	alloc]
				initCount:		0
				elementSize:	sizeof(texpatch_t)
				description:	NULL];
	[self	sortSelectedList];
	max = [selectedTexturePatches	count];
	for (i = 0;i < max;i++)
		[copyList		addElement:
			(texpatch_t *)[texturePatches elementAt:
			*(int *)[selectedTexturePatches elementAt:i]]];
	
	[selectedTexturePatches	empty];
	[textureView_i		display];
	return self;
}

//
// paste patches
//
- paste:sender
{
	texpatch_t	p;
	int	i,max = [copyList	count], val, xoff, yoff;
	NXRect	dvr;
	
	if (!max)
	{
		NXBeep();
		return self;
	}
	
	[scrollView_i	getDocVisibleRect:&dvr];
	xoff = dvr.origin.x - ((texpatch_t *)[copyList	elementAt:0])->r.origin.x;
	yoff = dvr.origin.y - ((texpatch_t *)[copyList	elementAt:0])->r.origin.y;
	
	[selectedTexturePatches	empty];
	for (i = 0; i < max; i++)
	{
		p = *(texpatch_t *)[copyList	elementAt:i];
		p.r.origin.x += 10 + xoff;
		p.r.origin.y += 10 + yoff;
		[texturePatches	addElement:&p];
		val = [texturePatches count] - 1;
		[selectedTexturePatches	addElement:&val];
	}
	[textureView_i		display];
	return self;
}

//
// move a patch up in the patch hierarchy
//
- sortUp:sender
{
	int	newpatch;
	texpatch_t	*t, t1, t2;

	if (	([self		getCurrentEditPatch] < 0) ||
		([texturePatches	count] - 1 == [self	getCurrentEditPatch]))
	{
		NXBeep();
		return self;
	}
	
	t = [texturePatches	elementAt:[self	getCurrentEditPatch]];
	if (t->patchLocked)
	{
		NXBeep();
		return self;
	}
	
	newpatch = [self	getCurrentEditPatch];
	do
	{
		newpatch++;
		t = [texturePatches	elementAt:newpatch];
		if (!t)
		{
			NXBeep();
			return self;
		}
	} while (t->patchLocked);

	t2 = *t;
	t = [texturePatches	elementAt:[self	getCurrentEditPatch]];
	t1 = *t;
	[texturePatches	removeElementAt:newpatch];
	[texturePatches	removeElementAt:[self	getCurrentEditPatch]];
	[texturePatches	insertElement:&t2	at:[self getCurrentEditPatch]];
	[texturePatches	insertElement:&t1	at:newpatch];
	[self	changeSelectedTexturePatch:0 to:newpatch];

	[textureView_i		display];
	return self;
}

//
// move a patch down in the patch hierarchy
//
- sortDown:sender
{
	int	newpatch;
	texpatch_t	*t, t1, t2;

	if ([self	getCurrentEditPatch] < 1)
	{
		NXBeep();
		return self;
	}
	
	t = [texturePatches	elementAt:[self	getCurrentEditPatch]];
	if (t->patchLocked)
	{
		NXBeep();
		return self;
	}
	
	newpatch = [self	getCurrentEditPatch];
	do
	{
		newpatch--;
		t = [texturePatches	elementAt:newpatch];
		if (!t)
		{
			NXBeep();
			return self;
		}
	} while (t->patchLocked);

	t2 = *t;
	t = [texturePatches	elementAt:[self	getCurrentEditPatch]];
	t1 = *t;
	[texturePatches	removeElementAt:[self	getCurrentEditPatch]];
	[texturePatches	removeElementAt:newpatch];
	[texturePatches	insertElement:&t1	at:newpatch];
	[texturePatches	insertElement:&t2	at:[self getCurrentEditPatch]];
	[self	changeSelectedTexturePatch:0 to:newpatch];

	[textureView_i		display];
	return self;
}

//===============================================================
//
//	Set patch X manually
//
//===============================================================
- changePatchX:sender
{
	texpatch_t	*tp;
	int			delta;
	
	if (![selectedTexturePatches	count])
		return self;
		
	tp = [texturePatches	elementAt:*(int *)
		[selectedTexturePatches  elementAt:0]];
		
	delta = 2*[texturePatchXField_i	intValue] - tp->r.origin.x;
	tp->r.origin.x += delta;
	tp->patchInfo.originx += delta/2;
	
	[textureView_i		display];
	
	return self;
}

//===============================================================
//
//	Set patch Y manually
//
//===============================================================
- changePatchY:sender
{
	texpatch_t	*tp;
	int			delta;
	
	if (![selectedTexturePatches	count])
		return self;

	tp = [texturePatches	elementAt:*(int *)
		[selectedTexturePatches  elementAt:0]];
		
	delta = 2*[texturePatchYField_i	intValue] - tp->r.origin.y;
	tp->r.origin.y += delta;
	tp->patchInfo.originy -= delta/2;
	
	[textureView_i		display];
	
	return self;
}

//===============================================================
//
//	Set a patch as selected in the Patch Palette
//	AND scroll the Patch Palette to that patch!
//
//===============================================================
- selectPatchAndScroll:(int)patch
{
	NXRect		r;
	apatch_t	*p;
	
	p = [patchImages	elementAt:patch ];
	[self	setSelectedPatch:patch];
	r = p->r;
	r.origin.x -= SPACING;
	r.origin.y -= SPACING;
	r.size.width += SPACING*2;
	r.size.height += SPACING*2;
	[texturePatchView_i	scrollRectToVisible:&r];
	[texturePatchScrollView_i	display];
	return self;
}

//===============================================================
//
//	Search for patch in Patch Palette
//
//===============================================================
- searchForPatch:sender
{
	char		string[9];
	apatch_t	*p;
	int	#import	"TextureEdit.h"
#import <appkit/appkit.h>

extern id	texturePalette_i;

typedef struct
{
	id	image;
	int	patchamount;
	char	 name[9];
	NXRect	r;
	int	WADindex;
	int	oldIndex;
} texpal_t;

@interface TexturePalette:Object
{
	id	window_i;
	id	texturePalView_i;
	id	texturePalScrView_i;
	id	titleField_i;
	id	widthField_i;
	id	heightField_i;
	id	searchField_i;
	id	patchField_i;
	id	widthSearch_i;
	id	heightSearch_i;
	
	id	texturePatches;
	id	allTextures;
	id	newTextures;
	int	selectedTexture;
	id	lsTextField_i;
	id	lsPanel_i;
	id	lsStatus_i;
}

- setupPalette;
- initTextures;
- finishInit;
- searchForTexture:sender;
- (int) getNumTextures;
- (int) getTextureIndex:(char *)name;
- createAllTextureImages;
- (texpal_t) createTextureImage:(int)which;

- computePalViewSize;
- (texpal_t *)getNewTexture:(int)which;
- (int)selectTextureNamed:(char *)name;

- (texpal_t *)getTexture:(int)which;
- storeTexture:(int)which;
- (char *)getSelTextureName;
- setSelTexture:(char *)name;
- (int) currentSelection;
- selectTexture:(int)val;
- menuTarget:sender;
- saveFrame;

- searchWidth:sender;
- searchHeight:sender;
- showTextureInMap:sender;

- saveTextureLBM:sender;
- saveAllTexturesAsLBM:sender;
- doSaveAllTexturesAsLBM:sender;

@end

//
//	Converting a texture to an LBM
//
void vgaPatchDecompress(patch_t *patchData,byte *dest_p);
void moveVgaPatch(byte *raw, byte *dest, int x, int y,
	int	width, int height,
	int clipwidth, int clipheight);
void createVgaTexture(char *dest, int which,int width, int height);
void createAndSaveLBM(char *name, int cs, FILE *fp);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ======================
void vgaPatchDecompress(patch_t *patchData,byte *dest_p)
{
	int		count;
	int		topdelta;
	int		i;
	int		index;
	int		width;
	int		height;
	byte	*data;

	//
	// translate the picture
	//
	width = patchData->width;
	height = patchData->height;
	memset(dest_p,255,width * height);
	
	for (i = 0;i < width; i++)
	{
		data = (byte *)patchData + LongSwap(patchData->collumnofs[i]);
		while (1)
		{
			topdelta = *data++;
			if (topdelta == (byte)-1)
				break;
			count = *data++;
			index = topdelta*width+i;	// destination index
			data++;						// skip top double
			while (count--)
			{
				*((unsigned char *)(dest_p + index)) = *data++;
				index += width;
			}
			data++;		// skip bottom double
		}
	}
}
                                                                                                                                                                                                                                                                                                          
#import <appkit/appkit.h>

#ifndef	H_DIVIDERT
#define	H_DIVIDERT
typedef struct
{
	int		x,y;
	char		string[32];
} divider_t;
#endif

@interface TexturePatchView:View
{
	id	dividers_i;
}

- addDividerX:(int)x Y:(int)y String:(char *)string;
- dumpDividers;

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         //
// docview of Patch Palette in TextureEdit
//
#import	"Coordinator.h"
#import 	"TexturePatchView.h"
#import	"TextureEdit.h"
@implementation TexturePatchView

//==============================================================
//
//	Init the storage for the Patch Palette dividers
//
//==============================================================
- initFrame:(const NXRect *)frameRect
{
	dividers_i = [	[ Storage alloc ]
				initCount:		0
				elementSize:	sizeof (divider_t )
				description:	NULL ];
				
	[super	initFrame:frameRect];
	return self;
}

//==============================================================
//
//	Add a Patch Palette divider (new set of patches)
//
//==============================================================
- addDividerX:(int)x Y:(int)y String:(char *)string;
{
	divider_t		d;
	
	d.x = x;
	d.y = y;
	strcpy (d.string, string );
	[dividers_i	addElement:&d ];
	
	return self;
}

//==============================================================
//
//	Dump all the dividers (for resizing)
//
//==============================================================
- dumpDividers
{
	[dividers_i	empty];
	return self;
}

//==============================================================
//
//	Draw the Patch Palette in the Texture Editor
//
//==============================================================
- drawSelf:(const NXRect *)rects :(int)rectCount
{
	int 		i, max, patchnum,selectedPatch;
	apatch_t	*patch;
	divider_t	*d;
	NXRect	clipview, r;

	selectedPatch = [textureEdit_i	getCurrentPatch];
	patchnum = 0;
	while ((patch = [textureEdit_i	getPatch:patchnum++]) != NULL)
		if (NXIntersectsRect(&patch->r,&rects[0]))
			[patch->image		composite:NX_SOVER toPoint:&patch->r.origin];
	
	[self	getFrame:&clipview];
	if (selectedPatch >= 0)
	{
		patch = [textureEdit_i	getPatch:selectedPatch];
		r = patch->r;
		r.origin.x -= 5;
		r.origin.y -= 5;
		r.size.width += 10;
		r.size.height += 10;
		DE_DrawOutline(&r);
		[patch->image		composite:NX_SOVER toPoint:&patch->r.origin];
	}

	//
	//	Draw patch set divider text
	//
	PSselectfont("Helvetica-Bold",12);
	PSrotate ( 0 );
	max = [dividers_i	count ];
	for (i = 0; i < max; i++)
	{
		d = [dividers_i	elementAt:i ];
		PSsetgray ( 0 );
		PSmoveto( d->x,d->y );
		PSshow ( d->string );
		PSstroke ();

		PSsetrgbcolor ( 148,0,0 );
		PSmoveto ( d->x, d->y + 12 );
		PSlineto ( bounds.size.width - SPACING*2, d->y + 12 );

		PSmoveto ( d->x, d->y - 2 );
		PSlineto ( bounds.size.width - SPACING*2, d->y - 2 );
		PSstroke ();
	}
	
	return self;
}

- mouseDown:(NXEvent *)theEvent
{
	NXPoint	loc;
	int		patchnum,selectedPatch;
	apatch_t *patch;
	
	loc = theEvent->location;
	[self convertPoint:&loc	fromView:NULL];
	
	selectedPatch = [textureEdit_i	getCurrentPatch];
	patchnum = 0;
	while ((patch = [textureEdit_i	getPatch:patchnum++]) != NULL)
		if ([self	mouse:&loc	inRect:&patch->r] == YES)
		{
			if (selectedPatch != patchnum -1)
				selectedPatch = patchnum - 1;
			
			if (theEvent->data.mouse.click == 2)
				[textureEdit_i	addPatch:selectedPatch];
				
			[textureEdit_i	setSelectedPatch:patchnum - 1];
			[superview	display];
			break;
		}

	return self;
}

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            		max;
	int			i;
	int			j;
	int			slen;
	
	strcpy(string,[patchSearchField_i	stringValue]);
	slen = strlen(string);
	
	max = [patchImages	count];
	if (selectedPatch < 0)
		selectedPatch = 0;
		
	for (i = selectedPatch+1;i < max;i++)
	{
		p = [patchImages	elementAt:i];
		for (j = 0;j < strlen(p->name);j++)
			if (!strncasecmp(string,p->name+j,slen))
			{
				[self	setSelectedPatch:i];
				return self;
			}
	}
	
	for (i = 0;i <= selectedPatch;i++)
	{
		p = [patchImages	elementAt:i];
		for (j = 0;j < strlen(p->name);j++)
			if (!strncasecmp(string,p->name+j,slen))
			{
				[self	setSelectedPatch:i];
				return self;
			}
	}
	
	return self;
}

//
// find in the Patch Palette the single patch selected in the Texture Editor
//
- findPatch:sender
{
	apatch_t	*patch;
	texpatch_t	*tp;
	int		pnum, c, max;
	
	c =[selectedTexturePatches	count];
	if (!c || c > 1)
	{
		NXBeep();
		return self;
	}
	
	tp = [texturePatches	elementAt:*(int *)[selectedTexturePatches  elementAt:0]];
	max = [patchImages	count ];
	for (pnum = 0; pnum < max; pnum++)
	{
		patch = [patchImages	elementAt:pnum ];
		if ( !strcasecmp (patch->name, tp->patchInfo.patchname ) )
			break;
	}
	
	[self	setSelectedPatch:pnum];
	return self;
}

//
// Internal routine. Non-useness
// Find highest #ed patch in selection list and return value & toast in list
//
- (int)findHighestNumberedPatch
{
	int	count = 0, high = 0, *val, pos = 0;
	while((val = [selectedTexturePatches	elementAt:count]) != NULL)
	{
		if (*val > high)
		{
			high = *val;
			pos = count;
		}
		count++;
	}
	[selectedTexturePatches	removeElementAt:pos];
	return high;
}

//
// delete all patches selected in the Texture Editor
//
- deleteCurrentPatch:sender
{
	int	count, i;
	
	count = [selectedTexturePatches	count];
	if (!count)
	{
		NXBeep();
		return self;
	}
	
	for (i = 0; i < count; i++)
		[texturePatches	removeElementAt:[self findHighestNumberedPatch]];
	[selectedTexturePatches	empty];
	
	[textureView_i		display];
	return self;
}

//
// return which patch is selected in edit view
//
- (int)getCurrentEditPatch
{
	int	amount;
	
	amount = [selectedTexturePatches	count];
	if (!amount || amount > 1)
		return -1;
	else
		return *(int *)[selectedTexturePatches	elementAt:0];
}

- (BOOL) selTextureEditPatchExists:(int)val
{
	int	count = 0,*v;
	while((v = [selectedTexturePatches	elementAt:count++]) != NULL)
		if (*v == val)
			return YES;
	return NO;
}

- updateTexPatchInfo
{
	texpatch_t	*t;
	int	c = [selectedTexturePatches	count];

	if (!c || c > 1)
	{
		[texturePatchXField_i	setIntValue:0];
		[texturePatchYField_i	setIntValue:0];
		[lockedPatch_i	setEnabled:NO];
		[texturePatchWidthField_i	setStringValue:NULL];
		[texturePatchHeightField_i	setStringValue:NULL];
		[texturePatchNameField_i	setStringValue:NULL];
	}
	else
	{
		t = [texturePatches	elementAt:*(int *)[selectedTexturePatches elementAt:0]];
		[texturePatchXField_i	setIntValue:t->r.origin.x / 2];
		[texturePatchYField_i	setIntValue:t->r.origin.y / 2];
		[lockedPatch_i	setEnabled:YES];
		[lockedPatch_i	setIntValue:t->patchLocked];
		[texturePatchWidthField_i	setIntValue:t->r.size.width / 2];
		[texturePatchHeightField_i	setIntValue:t->r.size.height / 2];
		[texturePatchNameField_i	setStringValue:t->patchInfo.patchname];
	}		
	return self;
}

- removeSelTextureEditPatch:(int)val
{
	int	count = 0,*v;
	while ((v = [selectedTexturePatches	elementAt:count]) != NULL)
		if (*v == val)
		{
			[selectedTexturePatches	removeElementAt:count ];
			break;
		}
		else
			count++;
	return self;
}

- getSTP
{
	return	selectedTexturePatches;
}

- changeSelectedTexturePatch:(int)which	to:(int)val
{
	*(int *)[selectedTexturePatches	elementAt:which] = val;
	return self;
}

//
// add texture patch # to selected array
//
- addSelectedTexturePatch:(int)val
{
	[selectedTexturePatches	addElement:&val];
	return self;
}

//
// patch lock switch was modified, so change patch flag
//
- doLockToggle
{
	[lockedPatch_i	setIntValue:1 - [lockedPatch_i intValue]];
	[self	togglePatchLock:NULL];
	return self;
}

- togglePatchLock:sender
{
	int	val;
	texpatch_t	*t;
	
	if ([self	getCurrentEditPatch] < 0)
	{
		NXBeep();
		return self;
	}
	val = [lockedPatch_i	intValue];
	t = [texturePatches	elementAt:[self	getCurrentEditPatch]];
	t->patchLocked = val;
	return self;
}

//
// return current patch in edit window
//
- (int)getCurrentPatch
{
	return	selectedPatch;
}

//
// the "outline patches" switch was modified, so redraw edit view
//
- outlineWasSet:sender
{
	[window_i	display];
	return self;
}

//
// return status of outline switch
//
- (int)getOutlineFlag
{
	return [outlinePatches_i		intValue];
}

//
// return * to patch image object
//
- (apatch_t *)getPatch:(int)which
{
	return	[patchImages	elementAt:which];
}

//=====================================================
//
//	TEXTURE STUFF
//
//=====================================================


//
// user changed the width/height/title of the texture. validate & change.
//
- changedWidthOrHeight:sender
{
	worldtexture_t		tex;
	texpatch_t		*p;
	int		count, deltay;
	NXRect	tr, nr;
	
	//
	// save texture first!
	//
	[self	finishTexture:nil];

	//
	// was width or height reduced?
	//
	if (	[textureWidthField_i	intValue] < textures[currentTexture].width ||
		[textureHeightField_i	intValue] < textures[currentTexture].height)
	{
		NXSetRect(&tr,0,0,
				[textureWidthField_i  intValue] * 2,[textureHeightField_i  intValue] * 2);
		count = 0;
		deltay = (textures[currentTexture].height - [textureHeightField_i  intValue]) * 2;
		while((p = [texturePatches	elementAt:count++]) != NULL)
		{
			NXSetRect(&nr,p->r.origin.x,p->r.origin.y - deltay,p->r.size.width,p->r.size.height);
			if (NXIntersectsRect(&nr,&tr) == NO)
			{
				NXBeep();
				NXRunAlertPanel("Oops!",
								"Changing the dimensions like that would leave one or more "
								"patches out in limbo!  Sorry, non-workness!",
								"OK",NULL,NULL);
				[textureWidthField_i	setIntValue:textures[currentTexture].width];
				[textureHeightField_i	setIntValue:textures[currentTexture].height];
				return self;
			}
		}
		
	}

	tex = textures[currentTexture];
	tex.width = [textureWidthField_i	intValue];
	tex.height = [textureHeightField_i	intValue];
	[doomproject_i	changeTexture:currentTexture to:&tex];
	[texturePalette_i		storeTexture:currentTexture];
	[self	newSelection:currentTexture];
	return self;
}

//
//	Create a new texture
//
- makeNewTexture:sender
{
	int	textureNum,rcode;
	worldtexture_t		tex;
	id	cell;
	
	if (![doomproject_i loaded])
		return self;
		
	//
	// create a default new texture
	//
	
	rcode = [NXApp	runModalFor:createTexture_i];
	[createTexture_i	close];
	if (rcode == NX_RUNABORTED)
		return self;

	tex.width = [createWidth_i	intValue];
	tex.height = [createHeight_i	intValue];
	tex.patchcount = 0;

	memset(tex.name,0,9);
	strncpy(tex.name,[createName_i	stringValue],8);

	cell = [setMatrix_i	selectedCell ];
	tex.WADindex = [cell	tag];
	
	//
	// add it to the world and edit it
	//
	textureNum = [doomproject_i	newTexture: &tex];
	[texturePalette_i	storeTexture: textureNum];
	[self	newSelection:textureNum];
	currentTexture = textureNum;
	//
	// load in all the texture patches
	//
	if (texturePatches)
		[texturePatches	free];
	texturePatches = [[	Storage	alloc]
					initCount:		0
					elementSize:	sizeof(texpatch_t)
					description:	NULL];
	[texturePalette_i	selectTexture:currentTexture];
	oldx = oldy = 0;			
	return self;
}

//
// clicked the "create it!" button in the New Texture dialog
//
- createTextureDone:sender
{
	char name[9];
	
	// clip texture name to 8 characters
	bzero(name,9);
	strncpy(name,[createName_i	stringValue],8);
	strupr(name);
	[createName_i	setStringValue:name];

	if (	[doomproject_i	textureNamed:name] >= -1)
	{
		NXBeep();
		NXRunAlertPanel("Oops!",
						"You already have a texture with the same name!",
						"OK",NULL, NULL, NULL);
		return self;
	}
	
	if (	[createWidth_i	intValue] &&
		[createHeight_i	intValue] &&
		strlen([createName_i	stringValue]))
		[NXApp	stopModal];
	else
		NXBeep();

	return self;
}

//
// approve the name entered in the dialog
//
- createTextureName:sender
{
	char name[9];
	
	// clip texture name to 8 characters
	bzero(name,9);
	strncpy(name,[createNam#import	"DoomProject.h"
#import	"TextureEdit.h"
#import	"TexturePalette.h"
#import	"TexturePalView.h"
#import	"lbmfunctions.h"
#import	"Wadfile.h"
#import	"TextLog.h"

id	texturePalette_i;

@implementation TexturePalette

- init
{
	window_i = NULL;
	texturePalette_i = self;
	selectedTexture = -1;

	allTextures = [[	Storage	alloc]
				initCount:		0
				elementSize:	sizeof(texpal_t)
				description:	NULL];
	
	return self;
}

- saveFrame
{
	if (window_i)
		[window_i	saveFrameUsingName:"TexturePalette"];
	return self;
}

- initTextures
{
	[self	createAllTextureImages];
	[self	finishInit];
	return self;
}

- finishInit
{
		NXPoint	p;
		NXRect	dvr;
	
		[self	computePalViewSize];
		//
		// start textures at top
		//
		[texturePalView_i		getFrame:&dvr];
		p.x = 0;
		p.y = dvr.size.height;
		[texturePalView_i		scrollPoint:&p];
		return self;
}

- setupPalette
{
		[self	finishInit];
		if ([allTextures	count])
			[self	selectTexture:0];
		[window_i	setFrameUsingName:"TexturePalette"];
		return self;
}

- menuTarget:sender
{
	if (![doomproject_i loaded])
	{
		NXRunAlertPanel("Oops!",
						"There must be a project loaded before you even\n"
						"THINK about choosing textures!",
						"OK",NULL,NULL,NULL);
		return self;
	}
		
	if (!window_i)
	{
		[NXApp 
			loadNibSection:	"TexturePalette.nib"
			owner:			self
			withNames:		NO
		];

		[self setupPalette];
		[window_i	setDelegate:self];
	}

	[window_i	makeKeyAndOrderFront:NULL];
	return self;
}

- windowDidMiniaturize:sender
{
	[sender	setMiniwindowIcon:"DoomEd"];
	[sender	setMiniwindowTitle:"TxPalette"];
	return self;
}


//
// create all the texture images for the palette
// NOTE: allTextures must have been created
//
- createAllTextureImages
{
	int		j;
	texpal_t	t;
	
	[allTextures	empty];
	
	for (j = 0; j < numtextures; j++)
	{
		t = [self	createTextureImage:j];
		[allTextures	addElement:&t];
	}

	return self;
}

//
// create a texture image from all its patches for the palette
// NOTE: allTextures must have been created
//
- (texpal_t) createTextureImage:(int)which
{
	int	i;
	texpal_t	t;
	NXSize	s;

	s.width = textures[which].width;
	s.height = textures[which].height;
	NXSetRect(&t.r,0,0,0,0);
	t.r.size = s;
	t.WADindex = textures[which].WADindex;
	strcpy(t.name,textures[which].name);
	t.patchamount = textures[which].patchcount;
	t.image = [[NXImage alloc]
			initSize:	&s];
	[t.image	 useCacheWithDepth:NX_TwelveBitRGBDepth];
	[t.image	lockFocusOn:[t.image lastRepresentation]];
	
	NXSetColor(NXConvertRGBAToColor(1,0,0,1));
	NXRectFill(&t.r);

	for (i = 0; i < textures[which].patchcount; i++)
	{
		texpatch_t	p;
		
		p.patchInfo = textures[which].patches[i];
		p.patch = [textureEdit_i	getPatchImage:p.patchInfo.patchname];
		if (!p.patch)
		{
			NXRunAlertPanel("Shit!",
				"While building texture #%d, I couldn't find "
				"the '%s' patch!","OK",NULL,NULL,i,p.patchInfo.patchname);
			[NXApp	terminate:NULL];
		}
		p.r.origin.x = p.patchInfo.originx;
		p.r.origin.y = (textures[which].height) - 
					(p.patch->r.size.height) - 
					(p.patchInfo.originy);
		p.r.size.width = p.patch->r.size.width;
		p.r.size.height = p.patch->r.size.height;
		[p.patch->image	composite:NX_SOVER toPoint:&p.r.origin];
	}
	[t.image	unlockFocus];
	return t;
}

//
// add/replace a texture image in palette
//
- storeTexture:(int)which
{
	texpal_t	*t,tex;
	
	if ((![allTextures	count]) ||
		(which > [allTextures	count] - 1))
			[allTextures	addElement:&tex];
	else
	{
		t = [allTextures	elementAt:which];
		[t->image	free];
	}
	
	tex = [self	createTextureImage:which];
	[allTextures	replaceElementAt:which with:&tex];

	[self	computePalViewSize];
	[self	selectTexture:which];
	[doomproject_i	setDirtyProject:TRUE];
	
	return self;
}

//=========================================================
//
//	Compute size of texture palette view from amount of texture images in allTextures
//
//=========================================================
- (texpal_t *)getNewTexture:(int)which
{
	return	[newTextures	elementAt:which];
}

- computePalViewSize
{
	texpal_t	*t, *t2;
	int		count,maxwidth,x,y;
	NXSize	s,imagesize;
	int		maxwindex, i, j;
	char		string[32];
	
	if (newTextures == nil )
		newTextures = [	[Storage alloc ]
						initCount: 	[allTextures  count]
						elementSize:	sizeof (texpal_t)
						description:	NULL ];
	else
		[newTextures	empty];
	
	maxwidth = 0;
	x = y = SPACING;
	count = [allTextures count] - 1;
	
	//
	//	See how many texture sets we have
	//
	maxwindex = 0;
	for (i = 0; i <= count; i++)
	{
		t = [allTextures	elementAt:i ];
		if (t->WADindex > maxwindex)
			maxwindex = t->WADindex;
	}
	
	//
	//	Build newTextures to hold texture sets in order
	//	from allTextures
	//
	for (i = 0; i <= maxwindex; i++)
		for (j = 0; j <= count; j++)
		{
			t = [allTextures	elementAt:j ];
			if (t->WADindex == i )
			{
				t->oldIndex = j;
				[newTextures	addElement: t ];
			}
		}

	//
	//	Compute Texture Palette size
	//
	[texturePalView_i	dumpDividers ];
	while (count >= 0)
	{
		t = [newTextures	elementAt:count];

		if (t->WADindex < maxwindex)
		{
			maxwindex = t->WADindex;
			sprintf (string, "Texture Set #%d", maxwindex+2 );
			y += SPACING;
			[texturePalView_i	addDividerX: x
					Y: y
					String: string ];
			y += SPACING*2;
		}
		
		t->r.origin.x = x;
		t->r.origin.y = y;
		[t->image	getSize:&imagesize];
		if (imagesize.width > maxwidth)
			maxwidth = imagesize.width;

		t2 = [allTextures	elementAt:t->oldIndex ];
		t2->r.origin.x = x;
		t2->r.origin.y = y;

		y += imagesize.height + SPACING;

		count--;
	}
	
	s.width = maxwidth + SPACING*2;
	s.height = y;
	[texturePalView_i	sizeTo:s.width :s.height];

	return self;
}

//
// return * to texture image[which]
//
- (texpal_t *)getTexture:(int)which
{
	return [allTextures	elementAt:which];
}

- (int)selectTextureNamed:(char *)name
{
	texpal_t *t;
	int		i;
	int		max;
	NXRect	r;
	
	max = [allTextures	count ];
	for (i = 0; i < max; i++)
	{
		t = [allTextures	elementAt:i ];
		if ( !strcasecmp (name, t->name ) )
			break;
	}
	
	selectedTexture = i;
	t = [self	getTexture:i];
	[titleField_i	setStringValue:t->name];
	[widthField_i	setIntValue:t->r.size.width];
	[heightField_i	setIntValue:t->r.size.height];
	[patchField_i	setIntValue:t->patchamount];
	r = t->r;
	r.origin.x -= SPACING;
	r.origin.y -= SPACING;
	r.size.width += SPACING*2;
	r.size.height += SPACING*2;
	[texturePalView_i	scrollRectToVisible:&r];
	[texturePalScrView_i	display];
	return i;
}

- selectTexture:(int)val
{
	texpal_t	*t;
	NXRect		r;
	
	selectedTexture = val;
	if (val >= 0)
	{
		t = [self	getTexture:val];
		[titleField_i	setStringValue:t->name];
		[widthField_i	setIntValue:t->r.size.width];
		[heightField_i	setIntValue:t->r.size.height];
		[patchField_i	setIntValue:t->patchamount];
		r = t->r;
		r.origin.x -= SPACING;
		r.origin.y -= SPACING;
		r.size.width += SPACING*2;
		r.size.height += SPACING*2;
		[texturePalView_i		scrollRectToVisible:&r];
		[texturePalScrView_i	display];
	}
	return self;
}

- (char *)getSelTextureName
{
	return	[self getTexture:selectedTexture]->name;
}

- setSelTexture:(char *)name
{
	int	i, max;
	NXRect	r;
	texpal_t	*t;
	
	max = [allTextures	count];
	for (i = 0;i < max; i++)
		if (!strcasecmp(name,((texpal_t *)(t = [allTextures elementAt:i]))->name))
		{
			if (!window_i)
				[self	menuTarget:NULL];
			else
				[window_i	orderFront:NULL];
			[self	selectTexture:i];
			r = t->r;
			r.origin.x -= SPACING;
			r.origin.y -= SPACING;
			r.size.width += SPACING*2;
			r.size.height += SPACING*2;
			[texturePalView_i	scrollRectToVisible:&r];
			[texturePalScrView_i	display];
			break;
		}
		
	return self;
}

- searchForTexture:sender
{
	int	i, max, slen,j;
	const char *string;
	texpal_t	*t;
	
	string = [searchField_i	stringValue];
	slen = strlen(string);
	max = [allTextures	count];
	
	for (i = selectedTexture+1;i < max;i++)
	{
		t = [allTextures	elementAt:i];
		for (j=0;j<strlen(t->name);j++)
			if (!strncasecmp(string,t->name+j,slen))
			{
				[self	setSelTexture:t->name];
				return self;
			}
	}
	
	for (i = 0;i <= selectedTexture;i++)
	{
		t = [allTextures	elementAt:i];
		for (j=0;j<strlen(t->name);j++)
			if (!strncasecmp(string,t->name+j,slen))
			{
				[self	setSelTexture:t->name];
				return selfe_i	stringValue],8);
	strupr(name);
	[createName_i	setStringValue:name];

	if (	[doomproject_i	textureNamed:name] >= -1)
	{
		NXBeep();
		NXRunAlertPanel("Oops!",
						"You already have a texture with the same name!",
						"OK",NULL, NULL, NULL);
	}
	return self;
}

- createTextureAbort:sender
{
	[NXApp	abortModal];
	return self;
}

//======================================================
//
//	Allows selection of another texture set when creating new texture
//
//======================================================
- createNewSet:sender
{
	int		nr, nc;
	id		cell;
	char		string[3];
	
	[setMatrix_i	getNumRows:&nr numCols:&nc ];
	if (nr == 5)
	{
		[newSetButton_i	setEnabled:NO ];
		NXBeep ();
		return self;
	}
	
	[setMatrix_i	addRow ];
	nr++;
	cell = [setMatrix_i	cellAt:nr-1 :0 ];
	sprintf (string, "%d",nr );
	[cell		setTitle:string ];
	[cell		setTag: nr-1 ];
	[setMatrix_i	sizeToCells ];
	[setMatrix_i	selectCell:cell ];
	[setMatrix_i	display ];
	
	return self;
}

//======================================================
//
//	Done editing texture. add to texture palette
//
//======================================================
- finishTexture:sender
{
	int	count;
	texpatch_t	*t;
	worldtexture_t		tex;
	
	//
	// copy texture info into textures array, then
	// add texture to palette
	//
	count = 0;
	tex.patchcount = [texturePatches count];
	tex.width = textures[currentTexture].width;
	tex.height = textures[currentTexture].height;
	tex.WADindex = textures[currentTexture].WADindex;
	
//	cell = [setMatrix_i	selectedCell ];
//	tex.WADindex = [cell	tag ];
	
	strcpy(tex.name,textures[currentTexture].name);
	while ([texturePatches	elementAt:count] != NULL)
	{
		t = [texturePatches elementAt:count];
		tex.patches[count] = t->patchInfo;
		count++;
	}
	[doomproject_i	changeTexture:currentTexture to:&tex];
	[texturePalette_i	storeTexture:currentTexture];
	
	return self;
}

//
// change to a new texture
//
- newSelection:(int)which
{
	texpatch_t	t;
	int	count,i;

	if (which < 0)
		return self;
		
	currentTexture = which;
	if (texturePatches)
		[texturePatches	free];
	
	texturePatches = [[	Storage	alloc]
					initCount:		0
					elementSize:	sizeof(texpatch_t)
					description:	NULL];
	
	//
	// copy textures from textures array to texturePatches
	//
	count = textures[which].patchcount;
	for (i = 0;i < count; i++)
	{
		t.patchLocked = 0;
		t.patchInfo = textures[which].patches[i];
		t.patch = [self	getPatchImage:t.patchInfo.patchname];
		t.r.origin.x = t.patchInfo.originx * 2;
		t.r.origin.y = (textures[which].height * 2) - 
					(t.patch->r.size.height * 2) - 
					(t.patchInfo.originy * 2);
		t.r.size.width = t.patch->r.size.width * 2;
		t.r.size.height = t.patch->r.size.height * 2;
		[texturePatches	addElement:&t];
		if (t.patch->image_x2 == NULL)
			[self	createPatchX2:t.patch];
	}	
	
	[selectedTexturePatches	empty];
	
	[textureView_i		sizeTo:textures[currentTexture].width * 2
					:textures[currentTexture].height * 2];
	[textureView_i		display];
	
	[textureWidthField_i	setIntValue:textures[currentTexture].width];
	[textureHeightField_i	setIntValue:textures[currentTexture].height];
	[textureNameField_i	setStringValue:textures[currentTexture].name];
	[textureSetField_i		setIntValue:textures[currentTexture].WADindex + 1 ];
	
	return self;
}

//
// return which texture we're working on
//
- (int)getCurrentTexture
{
	return currentTexture;
}

- setOldVars:(int)x :(int)y
{
	oldx = x;
	oldy = y;
	return self;
}

- setWarning:(BOOL)state
{
	if (state == YES)
		[dragWarning_i	setStringValue:"Selections dragged outside texture!"];
	else
		[dragWarning_i	setStringValue:" "];
	return self;
}

//
// user double-clicked on patch in patch palette.
// add that patch to the texture definition.
//
- addPatch:(int)which
{
	int	ct, ox, oy;
	NXRect	dvr;
	texpatch_t	p;
	apatch_t		*pi;
	
	[scrollView_i	getDocVisibleRect:&dvr];
	ct = currentTexture;
	ox = oldx;
	oy = oldy;
	
	if (ct < 0)
	{
		NXBeep();
		return self;
	}
	
	if ([texturePatches	count] == MAXPATCHES)
	{
		NXRunAlertPanel(	"Um!",
						"A maximum of 100 patches is in force!",
						"OK",NULL,NULL);
		return self;
	}
	
	if (dvr.size.width > textures[ct].width*2)
		dvr.size.width = textures[ct].width*2;
	if (dvr.size.height > textures[ct].height*2)
		dvr.size.height = textures[ct].height*2;

	memset(&p,0,sizeof(p));
	p.patchLocked = 0;
	p.patch = [patchImages	elementAt:which];

	if ([centerPatch_i intValue])
	{
		p.patchInfo.originx = dvr.origin.x/2 + dvr.size.width/4;
		p.patchInfo.originy = dvr.origin.y/2 + dvr.size.height/4;
	}
	else
	{
		//
		// add patch to right side of last patch added
		//
		if (ox >= textures[ct].width)
		{
			NXBeep();
			[centerPatch_i	setIntValue:1];
			p.patchInfo.originx = dvr.origin.x/2 + dvr.size.width/4;
			p.patchInfo.originy = dvr.origin.y/2 + dvr.size.height/4;
		}
		else
		{
			p.patchInfo.originx = ox;
			p.patchInfo.originy = oy;
		}
	}
	ox += p.patch->r.size.width;
	oldx = ox;
	
	memset(p.patchInfo.patchname,0,9);
	pi = [patchImages	elementAt:which ];
	strcpy ( p.patchInfo.patchname, pi->name );

	p.patchInfo.stepdir = 1;
	p.patchInfo.colormap = 0;

	p.r.origin.x = p.patchInfo.originx * 2;
	p.r.origin.y = (textures[ct].height * 2) - 
				(p.patch->r.size.height * 2) - 
				(p.patchInfo.originy * 2);
	p.r.size.width = p.patch->r.size.width * 2;
	p.r.size.height = p.patch->r.size.height * 2;
	
	[texturePatches	addElement:&p];
	//
	// Create x2-sized patch if it doesn't exist yet
	//
	if (p.patch->image_x2 == NULL)
		[self	createPatchX2:p.patch];
	
	//
	// scroll a little more to the right...
	//
	p.r.origin.x += p.r.size.width * 1.5;
	[textureView_i		scrollRectToVisible:&p.r];
	[textureView_i		display];
	return self;
}

- fillWithPatch:sender
{
	return self;
}

- sizeChanged:sender
{
	return self;
}

//=====================================================
//
//	PATCH PALETTE STUFF
//
//=====================================================

- (apatch_t *)getPatchImage:(char *)name
{
	int		i, max;
	apatch_t	*p;

	max = [patchImages	count ];
	for (i = 0; i < max; i++)
	{
		p = [patchImages	elementAt:i ];
		if ( !strcasecmp (name, p->name ) )
			return p;
	}
	return NULL;
}

//
// set patch selected in Patch Palette
//
- setSelectedPatch:(int)which
{
	apatch_t	*t;
	NXRect		r;
	
	selectedPatch = which;
	t = [patchImages	elementAt:which];
	[patchWidthField_i		setIntValue:t->r.size.width];
	[patchHeightField_i	setIntValue:t->r.size.height];
	[patchNameField_i		setStringValue: t->name ];
	
	r = t->r;
	r.origin.x -= SPACING;
	r.origin.y -= SPACING;
	r.size.width += SPACING*2;
	r.size.height += SPACING*2;
	[texturePatchView_i			scrollRectToVisible:&r];
	[texturePatchScrollView_i	display];
	return self;
}

//==========================================================
//
//	Get rid of all patches and their images
//
//==========================================================
- dumpAllPatches
{
	int			i, max;
	apatch_t		*p;
	id			panel;
	
	panel = NXGetAlertPanel("Wait...","Dumping texture patches.",
		NULL,NULL,NULL);
	[panel	orderFront:NULL];
	NXPing();
	
	max = [patchImages	count];
	for (i = 0; i < max; i++)
	{
		p = [patchImages	elementAt: i ];
		[ p->image	free ];
		if (p->image_x2 )
			[p->image_x2  free ];
	}
	
	[ patchImages	empty ];
	if (window_i)
	{
		[ window_i		free ];
		window_i = NULL;
	}
	
	[panel	orderOut:NULL];
	NXFreeAlertPanel(panel);
	return self;
}

//==========================================================
//
//	Load in all the patches and init storage array
//
//==========================================================
- initPatches
{
	int		patchStart, patchEnd, i;
	patch_t	*patch;
	byte 	*palLBM;
	unsigned short	shortpal[256];
	apatch_t	p;
	NXSize	s;
	char	string[80];
	
	int		windex;
	char	start[10], end[10];
	
	palLBM = [wadfile_i	loadLumpNamed:"playpal"];
	if (palLBM == NULL)
		IO_Error ("Need to have 'playpal' palette in .WAD file!");
	LBMpaletteTo16 (palLBM, shortpal);
	patchImages = [	[Storage	alloc]
					initCount:		0
					elementSize:	sizeof(apatch_t)
					description:	NULL];
		
	windex = 0;
	do
	{
		sprintf(string,"Loading patch set #%d for Texture Editor.",windex+1);
		[doomproject_i	initThermo:"One moment..." message:string];
		//
		// get inclusi;
			}
	}
	
	NXBeep();
	return self;
}

- (int) currentSelection
{
	return selectedTexture;
}

- (int) getNumTextures
{
	return [allTextures	count];
}

- (int) getTextureIndex:(char *)name
{
	int	i,max;
	texpal_t	*t;
	
	if ((name[0]=='-') || (!name[0] ))
		return -1;
	max = [allTextures	count];
	for (i = 0;i < max;i++)
	{
		t = [allTextures	elementAt:i];
		if (!strcasecmp(name,t->name))
			return i;
	}
	
	return -2;
}

//========================================================
//
//	Search for specific width
//
//========================================================
- searchWidth:sender
{
	int	i, max,width;
	texpal_t	*t;
	
	width = [widthSearch_i	intValue];
	max = [allTextures	count];
	for (i = selectedTexture + 1;i < max;i++)
	{
		t = [allTextures	elementAt:i];
		if (t->r.size.width == width)
		{
			[self	setSelTexture:t->name];
			return self;
		}
	}
	
	for (i = 0;i < selectedTexture;i++)
	{
		t = [allTextures	elementAt:i];
		if (t->r.size.width == width)
		{
			[self	setSelTexture:t->name];
			return self;
		}
	}
	
	NXBeep();
	return self;
}

//========================================================
//
//	Search for specific height
//
//========================================================
- searchHeight:sender
{
	int	i, max,height;
	texpal_t	*t;
	
	height = [heightSearch_i	intValue];
	max = [allTextures	count];
	for (i = selectedTexture + 1;i < max;i++)
	{
		t = [allTextures	elementAt:i];
		if (t->r.size.height == height)
		{
			[self	setSelTexture:t->name];
			return self;
		}
	}
	
	for (i = 0;i < selectedTexture;i++)
	{
		t = [allTextures	elementAt:i];
		if (t->r.size.height == height)
		{
			[self	setSelTexture:t->name];
			return self;
		}
	}
	
	NXBeep();
	return self;
}

//========================================================
//
//	Show current texture in map by highlighting all lines that use it
//
//========================================================
- showTextureInMap:sender
{
	int		i;
	int		found;
	char	 name[32];
	char	string[64];
	
	strcpy(name,[searchField_i	stringValue]);
	strupr(name);
	found = 0;
	[log_i	msg:"Searching for texture in lines...\n"];
	
	for (i = 0;i < numlines;i++)
		if ((!strcasecmp(lines[i].side[0].bottomtexture,name) ||
			!strcasecmp(lines[i].side[0].midtexture,name) ||
			!strcasecmp(lines[i].side[0].toptexture,name) ||
			!strcasecmp(lines[i].side[1].bottomtexture,name) ||
			!strcasecmp(lines[i].side[1].midtexture,name) ||
			!strcasecmp(lines[i].side[1].toptexture,name)) &&
			lines[i].selected != -1 )
		{
			[editworld_i	selectLine:i];
			[editworld_i	selectPoint:lines[i].p1];
			[editworld_i	selectPoint:lines[i].p2];
			sprintf(string,"Showing line #%d\n",i);
			[log_i	msg:string];
			found = 1;
		}

	[editworld_i	redrawWindows];
	if (found)
		NXBeep();
	return self;
}

//========================================================
//
//	Save currently selected texture out as an LBM !!!
//	and also save out .LS file for graphic
//
//========================================================
- saveTextureLBM:sender
{
	int		cs;
	char	lbmname[1024];
	char	lsname[1024];
	char	waddir[1024];
	int		i;
	FILE	*fp;
	
	cs = [self	currentSelection];
	if (cs < 0)
	{
		NXBeep();
		return self;
	}

	strcpy(waddir,[doomproject_i wadfile]);
	for (i = strlen(waddir);i > 0;i--)
		if (waddir[i] == '/')
		{
			waddir[i] = 0;
			break;
		}
		
	sprintf(lbmname,"%s/%s.LBM",waddir,textures[cs].name);
	sprintf(lsname,"%s/%s.LS",waddir,textures[cs].name);
	
	strlwr(lsname);
	fp = fopen (lsname,"w+");
	if (fp == NULL)
	{
		printf ("Error creating %s file!\n",lsname);
		return self;
	}

	strlwr(lbmname);
	createAndSaveLBM(lbmname, cs, fp);	
	fclose (fp);
	
	return self;
}

//========================================================
//
//	Save ALL textures out as LBMs !!!
//	and also save out .LS file for each graphic
//
//========================================================
- saveAllTexturesAsLBM:sender
{
	[lsPanel_i	makeKeyAndOrderFront:NULL];
	return self;
}

- doSaveAllTexturesAsLBM:sender
{
	char	lbmname[1024];
	char	lsEnteredName[24];
	char	waddir[1024];
	int		i;
	int		j;
	FILE	*fp;
	char	lsname[1024];
	char	status[32];
	
	
	strcpy(lsEnteredName,[lsTextField_i	stringValue]);
	if ((!lsEnteredName[0]) || strlen(lsEnteredName)>12)
	{
		NXBeep();
		return self;
	}
	
	strcpy(waddir,[doomproject_i wadfile]);
	for (i = strlen(waddir);i > 0;i--)
		if (waddir[i] == '/')
		{
			waddir[i] = 0;
			break;
		}
	
	if (strcmp(strupr(lsEnteredName + strlen(lsEnteredName)-3),".LS"))
		strcat(lsEnteredName,".LS");
	
	sprintf(lsname,"%s/%s",waddir,lsEnteredName);
	strlwr(lsname);	
	
	fp = fopen (lsname,"w+");
	if (fp == NULL)
	{
		printf ("Error creating %s file!\n",lsname);
		return self;
	}
	
	for (j = 0; j < numtextures; j++)
	{
		sprintf(lbmname,"%s/%s.LBM",waddir,textures[j].name);
		sprintf(status,"Making %s.LBM...",textures[j].name);
		
		[lsStatus_i	setStringValue:status];
		NXPing();
		strlwr(lbmname);
		createAndSaveLBM(lbmname, j, fp);
	}

	fclose (fp);
	
	[lsPanel_i	close];
	return self;
}


@end

//========================================================
//
//	Create and Save an LBM along with the LS info
//
//	name = what to name the LBM
//	cs   = which texture to create an LBM of
//	fp   = FILE * for .LS script
//
//========================================================
void createAndSaveLBM(char *name, int cs, FILE *fp)
{
	byte	*texturedata;
	byte	*palette;
	int		tw;
	int		th;
	
	[ wadfile_i	initFromFile: [doomproject_i wadfile] ];
	palette = [wadfile_i	loadLumpNamed:"playpal"];
	[ wadfile_i	close ];
	
	tw = textures[cs].width;
	th = textures[cs].height;
	texturedata = malloc(tw * th);
	memset(texturedata,255,tw * th);
	
	//	CREATE THE TEXTURE GRAPHIC
	createVgaTexture(texturedata, cs, tw, th);

	// CREATE THE .LBM
	SaveRawLBM (name, texturedata, tw, th, palette);

	free(texturedata);
	
	// CREATE THE LUMPY SCRIPT
	fprintf(fp,"\x0d\n$load %s.lbm\x0d\n",textures[cs].name);
	fprintf(fp,"%s	VRAW	0	0	%d	%d\x0d\n\x0d\n",
			textures[cs].name,tw,th);
}


//========================================================
//
//	Construct a VGA texture from VGA patches
//
//========================================================
void createVgaTexture(char *dest, int which,int width, int height)
{
	int		i;
	int		patchw;
	int		patchh;
	
	[ wadfile_i	initFromFile: [doomproject_i wadfile] ];
	
	for (i = 0; i < textures[which].patchcount; i++)
	{
		worldpatch_t	*p;
		patch_t			*patch;
		byte			*raw;
		
		//	For each patch in texture:
		//		a. load patch from WAD
		//		b. convert patch to VGA raw
		//		c. blit raw to dest buffer x,y
		
		p = &textures[which].patches[i];
		
		patch = [wadfile_i	loadLumpNamed:p->patchname];
		patchw = patch->width;
		patchh = patch->height;
		raw = malloc(patchw * patchh);
		
		vgaPatchDecompress(patch,raw);
		moveVgaPatch(raw, dest, p->originx, p->originy, patchw, patchh,
			width, height);
		
		free(raw);
		free(patch);
	}

	[ wadfile_i	close ];
}

//========================================================
//
//	Move VGA raw data to x,y in dest buffer
//
//	raw 	= source data
//	dest	= destination buffer
//	x		= dest buffer x
//	y		= dest buffer y
//	width	= raw's width
//	height	= raw's height
//	clipwidth = dest's width
//	clipheight = dest's height
//
//========================================================
void moveVgaPatch(byte *raw, byte *dest, int x, int y,
	int	width, int height,
	int clipwidth, int clipheight)
{
	int		i;
	int		nwidth;
	int		nheight;
	int		xoff;
	int		yoff;
	int		j;
	int		val;
	byte	*src;
	byte	*dst;
	
	nwidth = width;
	if (x + width > clipwidth)
		nwidth = clipwidth - x;
		
	nheight = height;
	if (y + height > clipheight)
		nheight = clipheight - y;
	
	xoff = 0;
	if (x < 0)
	{
		xoff = abs(x);
		x = 0;
	}
	
	yoff = 0;
	if (y < 0)
	{
		yoff = abs(y);
		y = 0;
	}
		
	dst = dest + y*width + x;
	for (i = yoff; i < nheight; i++)
	{
		src = raw + i*width + xoff;
		dst = dest + y*clipwidth + x + (i-yoff)*clipwidth;
		for (j = xoff; j < nwidth; j++)
		{
			val = *src++;
			if (val != 255)
				*dst = val;
			dst++;
		}
	}
}

//========================================================
//
//	Decompress VGA patch data into raw VGA block shape
//
//==================================ve lump #'s for patches
		//
		sprintf (start, "p%d_start", windex+1 );
		sprintf (end,"p%d_end", windex+1 );
		patchStart = [wadfile_i	lumpNamed:start] + 1;
		patchEnd = [wadfile_i	lumpNamed:end];
	
		if (patchStart == -1 || patchEnd == -1)
		{
			if (!windex)
				NXRunAlertPanel(	"OOPS!",
					"There are NO PATCHES in the current .WAD file!",
					"Abort Patch Palette",NULL,NULL,NULL);
			
			windex = -1;
			continue;
		}
		
		NXSetRect(&p.r,0,0,0,0);
		for (i = patchStart; i < patchEnd; i++)
		{
			[doomproject_i	updateThermo:i-patchStart max:patchEnd-patchStart];
			//
			// load vertically compressed patch and convert to an NXImage
			//
			patch = [wadfile_i	loadLump:i];
			memset(&p,0,sizeof(p));
			strcpy(p.name,[wadfile_i  lumpname:i]);
			p.name[8] = 0;
			p.image = patchToImage(patch,shortpal,&s,p.name);
			p.image_x2 = NULL;
			p.size = s;
			p.r.size = s;
			p.WADindex = windex;
			[patchImages	addElement:&p];
			free(patch);
		}
		
		windex++;
	} while (windex >= 0);	

	free(palLBM);
	[doomproject_i	closeThermo];
	return self;
}

//
// make a copy that's 2 times the size
//
- createPatchX2:(apatch_t *)p
{
	NXSize	theSize;
	
	p->image_x2 = [p->image	copyFromZone:NXDefaultMallocZone()];
	theSize = p->size;
	theSize.width *= 2;
	theSize.height *= 2;
	[p->image_x2	setScalable:YES];
	[p->image_x2	setSize:&theSize];
	return self;
}		

//
//	Return # of patches
//
- (int)getNumPatches
{
	return [patchImages	count];
}

//
//	Return index of patch from name
//
- (int)findPatchIndex:(char *)name
{
	int		i, max;
	apatch_t	*p;
	
	max = [patchImages	count];
	for (i = 0;i < max; i++)
	{
		p = [patchImages	elementAt:i];
		if (!strcasecmp(p->name,name))
			return i;
	}
	
	return -1;
}

//
//	Return name of patch from index
//
- (char *)getPatchName:(int)which;
{
	apatch_t	*p;
	
	if (which > [patchImages count])
		return NULL;
	p = [patchImages	elementAt:which];
	return p->name;
}

//
//	Locate patch use in textures
//
- locatePatchInTextures:sender
{
	int	i, j, max, cs;
	char *pname;
	
	if (selectedPatch < 0)
		return self;
		
	pname = [self	getPatchName:selectedPatch];
	
	cs = [texturePalette_i	currentSelection];
	max = [texturePalette_i	getNumTextures];
	for (i = cs+1;i < max; i++)
		for (j = 0; j < textures[i].patchcount; j++)
			if (!strcasecmp(textures[i].patches[j].patchname,pname))
			{
				[texturePalette_i	selectTexture:i];
				[texturePalette_i	setSelTexture:[texturePalette_i getSelTextureName]];
				return self;
			}

	for (i = 0;i <= cs; i++)
		for (j = 0; j < textures[i].patchcount; j++)
			if (!strcasecmp(textures[i].patches[j].patchname,pname))
			{
				[texturePalette_i	selectTexture:i];
				[texturePalette_i	setSelTexture:[texturePalette_i getSelTextureName]];
				return self;
			}
			
	NXBeep ();
	return self;
}

//
// user resized the Texture Edit window.
// change the size of the patch palette.
//
- windowDidResize:sender
{
	NXRect	r;
	
	[self		computePatchDocView:&r];
	[texturePatchView_i	sizeTo:r.size.width :r.size.height];
	[window_i	display];
	return self;
}

//
// compute the size of the docView and set the origin of all the patches
// within the docView.
//
- computePatchDocView: (NXRect *)theframe
{
	NXRect	curWindowRect;
	int		x, y, patchnum, maxheight;
	apatch_t	*patch;
	int		maxwindex;
	char		string[32];
	
	[texturePatchScrollView_i		getDocVisibleRect:&curWindowRect];
	x = y =  SPACING;
	maxheight = patchnum = maxwindex = 0;
	while ((patch = [patchImages	elementAt:patchnum++]) != NULL)
	{
		//
		//	Add some space if a new Patch Set is detected
		//
		if (patch->WADindex > maxwindex )
		{
			maxwindex = patch->WADindex;
			x = SPACING;
			y += 80 + maxheight;
		}
	
		if (x + patch->r.size.width > curWindowRect.size.width && x != SPACING)
		{
			x = SPACING;
			y += maxheight + SPACING;
			maxheight = 0;
		}
		
		if (patch->r.size.height > maxheight)
			maxheight = patch->r.size.height;

		if (x + patch->r.size.width > curWindowRect.size.width && x == SPACING)
		{
			y += maxheight + SPACING;
			maxheight = 0;
		}			
		else
			x += patch->r.size.width + SPACING;
	}
	y += maxheight + SPACING;
	NXSetRect(theframe,0,0,curWindowRect.size.width + SPACING,y);
	
	//
	// now go through all the patches and reassign the coords so they
	// stack from top to bottom...
	//
	[texturePatchView_i	dumpDividers];
	maxheight = patchnum = maxwindex = 0;
	x = theframe->origin.x + SPACING;
	y = theframe->origin.y + theframe->size.height - SPACING;
	while ((patch = [patchImages	elementAt:patchnum++]) != NULL)
	{
		//
		//	If a new Patch Set is detected, insert a divider
		//
		if (patch->WADindex > maxwindex )
		{
			maxwindex = patch->WADindex;
			x = SPACING;
			y -= 40 + maxheight;
			sprintf ( string, "Patch Set #%d", maxwindex+1 );
			[texturePatchView_i	addDividerX:x
						Y: y
						String: string ];
			y -= 40;
		}
		
		if (x + patch->r.size.width > curWindowRect.size.width && x != SPACING)
		{
			x = SPACING;
			y -= maxheight + SPACING;
			maxheight = 0;
		}
		
		patch->r.origin.x = x;
		patch->r.origin.y = y - patch->r.size.height;

		if (patch->r.size.height > maxheight)
			maxheight = patch->r.size.height;

		if (x + patch->r.size.width > curWindowRect.size.width && x == SPACING)
		{
			y -= maxheight + SPACING;
			maxheight = 0;
		}			
		else
			x += patch->r.size.width + SPACING;
	}	

	return self;
}


@end

//---------------------------------------------------------------
//
// C ROUTINES
//
//---------------------------------------------------------------



//
// convert a compressed patch to an NXImage with an alpha channel
//
id	patchToImage(patch_t *patchData, unsigned short *shortpal,NXSize *size,char *name)
{
	byte			*dest_p;
	NXImageRep *image_i;
	id			fastImage_i;
	int			width,height,count,topdelta;
	byte const	*data;
	int			i,index;

	width = ShortSwap(patchData->width);
	height = ShortSwap(patchData->height);
	size->width = width;
	size->height = height;
	
	if (!width || !height)
	{
		printf("Can't create NXBitmapImage of %s!  "
			"Width or height = 0.\n",name);
		return NULL;
	}
	//
	// make an NXimage to hold the data
	//
	image_i = [[NXBitmapImageRep alloc]
		initData:			NULL 
		pixelsWide:		width 
		pixelsHigh:		height
		bitsPerSample:	4
		samplesPerPixel:	4 
		hasAlpha:		YES
		isPlanar:			NO 
		colorSpace:		NX_RGBColorSpace 
		bytesPerRow:		width*2
		bitsPerPixel: 		16
	];

	if (!image_i)
		return nil;
				
	//
	// translate the picture
	//
	dest_p = [(NXBitmapImageRep *)image_i data];
	memset(dest_p,0,width * height * 2);
	
	for (i = 0;i < width; i++)
	{
		data = (byte *)patchData + LongSwap(patchData->collumnofs[i]);
		while (1)
		{
			topdelta = *data++;
			if (topdelta == (byte)-1)
				break;
			count = *data++;
			index = (topdelta*width+i)*2;
			data++;		// skip top double
			while (count--)
			{
				*((unsigned short *)(dest_p + index)) = shortpal[*data++];
				index += width * 2;
			}
			data++;		// skip bottom double
		}
	}

	fastImage_i = [[NXImage	alloc]
							init];
	[fastImage_i	useRepresentation:(NXImageRep *)image_i];	
	return fastImage_i;
}

char *strupr(char *string)
{
	char *s = string;
	while (*string)
		*string++ = toupper(*string);
	return s;
}

char *strlwr(char *string)
{
	char *s = string;
	while (*string)
		*string++ = tolower(*string);
	return s;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #import	"Remapper.h"
#import <appkit/appkit.h>

extern	id	textureRemapper_i;

@interface TextureRemapper:Object <Remapper>
{
	id	remapper_i;
}

- addToList:(char *)orgname to:(char *)newname;

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #import	"EditWorld.h"
#import	"TexturePalette.h"
#import	"TextureRemapper.h"

id	textureRemapper_i;

@implementation TextureRemapper

//===================================================================
//
//	REMAP TEXTURES IN MAP
//
//===================================================================
- init
{
	textureRemapper_i = self;
	
	remapper_i = [ [ Remapper	alloc ]
				setFrameName:"TextureRemapper"
				setPanelTitle:"Texture Remapper"
				setBrowserTitle:"List of textures to be remapped"
				setRemapString:"Texture"
				setDelegate:self ];
	return self;
}

//===================================================================
//
//	Bring up panel
//
//===================================================================
- menuTarget:sender
{
	[remapper_i	showPanel];
	return self;
}

- addToList:(char *)orgname to:(char *)newname;
{
	[remapper_i	addToList:orgname to:newname];
	return self;
}

//===================================================================
//
//	Delegate methods
//
//===================================================================
- (char *)getOriginalName
{
	return [texturePalette_i	getSelTextureName];
}

- (char *)getNewName
{
	return [texturePalette_i	getSelTextureName];
}

- (int)doRemap:(char *)oldname to:(char *)newname
{
	int		i;
	int		linenum;
	int		flag;
	
	linenum = 0;
	for (i = 0;i < numlines; i++)
	{
		flag = 0;
		// SIDE 0
		if (!strcasecmp ( oldname,lines[i].side[0].bottomtexture))
		{
			strcpy(lines[i].side[0].bottomtexture, newname );
			flag++;
		}
		if (!strcasecmp( oldname,lines[i].side[0].midtexture))
		{
			strcpy(lines[i].side[0].midtexture, newname );
			flag++;
		}
		if (!strcasecmp( oldname ,lines[i].side[0].toptexture))
		{
			strcpy(lines[i].side[0].toptexture, newname );
			flag++;
		}

		// SIDE 1
		if (!strcasecmp ( oldname,lines[i].side[1].bottomtexture))
		{
			strcpy(lines[i].side[1].bottomtexture, newname );
			flag++;
		}
		if (!strcasecmp( oldname,lines[i].side[1].midtexture))
		{
			strcpy(lines[i].side[1].midtexture, newname );
			flag++;
		}
		if (!strcasecmp( oldname ,lines[i].side[1].toptexture))
		{
			strcpy(lines[i].side[1].toptexture, newname );
			flag++;
		}
		
		if (flag)
		{
			printf("Remapped texture %s to %s.\n",oldname,newname);
			linenum++;
		}
	}
	
	return linenum;
}

- finishUp
{
	return self;
}

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
#import <appkit/appkit.h>

typedef struct
{
	int	xoff,yoff;
	texpatch_t *p;
} delta_t;

@interface TextureView:View
{
	id	deltaTable;
}


@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
#import <appkit/appkit.h>

@interface ThermoView:View
{
	float		thermoWidth;
}

- setThermoWidth:(int)current max:(int)maximum;

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
#import "ThermoView.h"

@implementation ThermoView

- setThermoWidth:(int)current max:(int)maximum
{
	thermoWidth = bounds.size.width*((float)current/(float)maximum);
	return self;
}

- drawSelf:(const NXRect *)rects :(int)rectCount
{
	PSsetlinewidth(bounds.size.height);

	PSsetrgbcolor(0.5,1.0,1.0);
	PSmoveto(0,bounds.size.height/2);
	PSlineto(thermoWidth,bounds.size.height/2);
	PSstroke();
	
	PSsetgray(0.5);
	PSmoveto(thermoWidth+1,bounds.size.height/2);
	PSlineto(bounds.size.width,bounds.size.height/2);
	PSstroke();

	return self;
}

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
#import <appkit/appkit.h>

@interface ThingPalView:View
{
}


@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            //
// This belongs to TextureEdit (docView of TextureEdit's ScrollView)
//
#import "TextureEdit.h"
#import "EditWorld.h"
#import "TextureView.h"
//#import "wadfiles.h"


@implementation TextureView

- (BOOL) acceptsFirstResponder
{
	return YES;
}

- initFrame:(const NXRect *)frameRect
{
	[super initFrame:frameRect];
	deltaTable = [[ Storage	alloc ]
					initCount:0
					elementSize:sizeof(delta_t)
					description:NULL];

	return self;
}

- keyDown:(NXEvent *)theEvent
{
	switch(theEvent->data.key.charCode)
	{
		case 0x7f:	// delete patch
			[textureEdit_i	deleteCurrentPatch:NULL];
			break;
		case 0x6c:	// toggle lock
			[textureEdit_i	doLockToggle];
			break;
		case 0xac:
		case 0xaf:	// sort down
			[textureEdit_i	sortDown:NULL];
			break;
		case 0xad:
		case 0xae:	// sort up
			[textureEdit_i	sortUp:NULL];
			break;
		case 0xd:
			[textureEdit_i	finishTexture:NULL];
			break;
		#if 0
		default:
			printf("charCode:%x\n",theEvent->data.key.charCode);
			break;
		#endif
	}
	return self;
}

- drawSelf:(const NXRect *)rects :(int)rectCount
{
	int		ct,i,outlineflag;
	int		patchCount;
	texpatch_t	*tpatch;
	
	ct = [textureEdit_i	getCurrentTexture];
	if (ct < 0)
		return self;
		
	NXSetColor(NXConvertRGBToColor(1,0,0));
	NXRectFill(&rects[0]);
	
	outlineflag = [textureEdit_i	getOutlineFlag];
	PSsetgray(NX_DKGRAY);

	//
	// draw all patches
	//
	patchCount = [texturePatches	count];
	for (i = 0;i < patchCount; i++)
	{
		tpatch = [texturePatches	elementAt:i];
//		if (NXIntersectsRect(&tpatch->r,&rects[0]) == YES)
			[tpatch->patch->image_x2	composite:NX_SOVER toPoint:&tpatch->r.origin];
	}

	//
	// overlay outlines
	//
	if (outlineflag)
		for (i = patchCount - 1;i >= 0;i--)
		{
			tpatch = [texturePatches	elementAt:i];
//			if (NXIntersectsRect(&tpatch->r,&rects[0]) == YES)
				NXFrameRectWithWidth(&tpatch->r,5);
		}

	//
	// if multiple selections, draw their outlines
	//
	if ([[textureEdit_i	getSTP]		count])
	{
		int	max;
		
		max = [[textureEdit_i	getSTP]	count];
		for (i = 0;i<max;i++)
		{
			tpatch = [texturePatches	elementAt:*(int *)[[textureEdit_i getSTP] elementAt:i]];
			PSsetgray(NX_WHITE);
			NXFrameRectWithWidth(&tpatch->r,5);
		}
	}
	
	return self;
}

- rightMouseDown:(NXEvent *)theEvent
{
	[[textureEdit_i	getSTP]	empty];
	[self	display];
	return self;
}

- mouseDown:(NXEvent *)theEvent
{
	NXPoint	loc,newloc;
	int	i,patchcount,oldwindowmask,ct,max,j,warn,clicked;
	texpatch_t	*patch;
	NXEvent	*event;

	oldwindowmask = [window addToEventMask:NX_LMOUSEDRAGGEDMASK];
	loc = theEvent->location;
	[self convertPoint:&loc	fromView:NULL];
	ct = [textureEdit_i	getCurrentTexture];

	//
	// see if a patch was clicked on...
	//
	patchcount = [texturePatches	count];
	clicked = 0;		// no patch clicked on yet...
	for (i = patchcount - 1;i >= 0;i--)
	{
		patch = [texturePatches	elementAt:i];
		if (NXPointInRect(&loc,&patch->r) == YES)
		{
			//
			// shift-click adds the patch to the select list
			//
			if (theEvent->flags & NX_SHIFTMASK)
			{
				if ([textureEdit_i	selTextureEditPatchExists:i] == NO)
					[textureEdit_i	addSelectedTexturePatch:i];
				else
					[textureEdit_i	removeSelTextureEditPatch:i];
				[textureEdit_i	updateTexPatchInfo];
			}
			else
			if (![textureEdit_i	selTextureEditPatchExists:i])
			{
				[[textureEdit_i	getSTP]	empty];
				[textureEdit_i	addSelectedTexturePatch:i];
				[textureEdit_i	updateTexPatchInfo];
			}
			[self	display];
			clicked = 1;
			break;
		}
	}
	
	//
	// Did user click outside area? If so, get rid of all selections
	//
	if (!clicked)
		[[textureEdit_i	getSTP]	empty];
	
	//
	// move around texture patches
	//
	max = [[textureEdit_i getSTP]	count];
	[deltaTable	empty];
	for (j = 0; j < max; j++)
	{
		delta_t	d;
		d.p = [texturePatches	elementAt:
				*(int *)[[textureEdit_i getSTP] elementAt:j]];
		d.xoff = loc.x - d.p->r.origin.x;
		d.yoff = loc.y - d.p->r.origin.y;
		[deltaTable	addElement:&d];
	}
	
	do
	{
		event = [NXApp getNextEvent:	NX_MOUSEUPMASK |									NX_MOUSEDRAGGEDMASK];
		newloc = event->location;
		[self convertPoint:&newloc  fromView:NULL];
		warn = 0;
		for (j = 0;j < max;j++)
		{
			delta_t	*d;
			NXPoint	l;
			
			d = [deltaTable	elementAt:j];
			l = newloc;
			l.x = ((int)l.x - d->xoff) & -2;
			l.y = ((int)l.y - d->yoff) & -2;
			//
			// dragged selections off texture? if so, pull back the ones already lost.
			//
			if (l.x < 0 || l.y < 0 || l.x/2 > textures[ct].width || l.y/2 > textures[ct].height)
				warn = 1;
			d->p->r.origin = l;
			d->p->patchInfo.originx = l.x / 2;
			d->p->patchInfo.originy = textures[ct].height - 
								((l.y / 2) + (d->p->r.size.height / 2));

		}
		[ self		display ];
		[textureEdit_i	updateTexPatchInfo];
		[textureEdit_i	setWarning:warn];
	} while (event->type != NX_MOUSEUP);

	if ([[textureEdit_i	getSTP] count] == 1)
	{
		delta_t *d;
		d = [deltaTable elementAt:0];
//		[textureEdit_i	setOldVars:d->p->patchInfo.originx + d->p->r.size.width/2
//					:(textures[ct].height - d->p->patchInfo.originy) - d->p->r.size.height/2];
		[textureEdit_i	setOldVars:d->p->patchInfo.originx + d->p->r.size.width/2
					:d->p->patchInfo.originy];
	}
	return self;
}

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
#import <appkit/appkit.h>

@interface TextureWindow:Window
{
}

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
#import "TextureWindow.h"

@implementation TextureWindow

- init
{
	
	return self;
}


@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
#import "ThingPalView.h"
#import	"ThingPalette.h"
#import	"DoomProject.h"
#import	"ThingPanel.h"

@implementation ThingPalView

- drawSelf:(const NXRect *)rects :(int)rectCount
{
	icon_t	*icon;
	int		max;
	int		i;
	int		ci;
	NXRect	r;
	NXPoint	p;
	
	ci = [thingPalette_i	getCurrentIcon];
	if (ci >= 0)
	{
		icon = [thingPalette_i	getIcon:ci];
		r = icon->r;
		r.origin.x -= 5;
		r.origin.y -= 5;
		r.size.width += 10;
		r.size.height += 10;
		DE_DrawOutline(&r);
	}
	
	max = [thingPalette_i	getNumIcons];
	for (i = 0; i < max; i++)
	{
		icon = [thingPalette_i	getIcon:i];
		if (NXIntersectsRect(&rects[0],&icon->r) == YES)
		{
			p = icon->r.origin;
			p.x += (ICONSIZE - icon->imagesize.width)/2;
			p.y += (ICONSIZE - icon->imagesize.height)/2;
			[icon->image	composite:NX_SOVER	toPoint:&p];
		}
	}

	//
	//	Draw icon divider text
	//
	PSselectfont("Helvetica-Bold",12);
	PSrotate ( 0 );
	for (i = 0; i < max; i++)
	{
		icon = [thingPalette_i	getIcon:i ];
		if (icon->image != NULL)
			continue;
			
		PSsetgray ( 0 );
		PSmoveto( icon->r.origin.x,icon->r.origin.y + ICONSIZE/2);
		PSshow ( icon->name );
		PSstroke ();

		PSsetrgbcolor ( 148,0,0 );
		PSsetlinewidth( 1.0 );
		PSmoveto ( icon->r.origin.x, icon->r.origin.y + ICONSIZE/2 + 12 );
		PSlineto ( bounds.size.width - SPACING,
				icon->r.origin.y + ICONSIZE/2 + 12 );

		PSmoveto ( icon->r.origin.x, icon->r.origin.y + ICONSIZE/2 - 2 );
		PSlineto ( bounds.size.width - SPACING,
				icon->r.origin.y + ICONSIZE/2 - 2 );
		PSstroke ();
	}
	
	return self;
}

- mouseDown:(NXEvent *)theEvent
{
	NXPoint	loc;
	int		i;
	int		max;
	int		oldwindowmask;
	icon_t	*icon;

	oldwindowmask = [window addToEventMask:NX_LMOUSEDRAGGEDMASK];
	loc = theEvent->location;
	[self convertPoint:&loc	fromView:NULL];
	
	max = [thingPalette_i	getNumIcons];
	for (i = 0;i < max; i++)
	{
		icon = [thingPalette_i		getIcon:i];
		if (NXPointInRect(&loc,&icon->r) == YES)
		{
			[thingPalette_i	setCurrentIcon:i];
			[thingpanel_i	selectThingWithIcon:icon->name];
			break;
		}
	}
	
	[window	setEventMask:oldwindowmask];
	return self;
}

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
#import <appkit/appkit.h>

typedef struct
{
	NXRect	r;
	NXSize	imagesize;
	char	name[10];
	id		image;
} icon_t;

#define	SPACING		10
#define	ICONSIZE	48

extern id	thingPalette_i;

@interface ThingPalette:Object
{
	id		window_i;			// outlet
	id		thingPalView_i;		// outlet
	id		thingPalScrView_i;	// outlet
	id		nameField_i;		// outlet
	
	id		thingImages;		// Storage for icons
	int		currentIcon;		// currently selected icon
}

- menuTarget:sender;
- (int)findIcon:(char *)name;
- (icon_t *)getIcon:(int)which;
- (int)getCurrentIcon;
- setCurrentIcon:(int)which;
- (int)getNumIcons;
- computeThingDocView;
- initIcons;
- dumpAllIcons;


@end
                                                                                                                                                                                                                                                                                                                                                                                             
#import <appkit/appkit.h>
#import 	"DoomProject.h"
#import		"EditWorld.h"

extern	id	thingpanel_i;

typedef struct
{
	char		name[32];
	char		iconname[9];
	NXColor	color;
	int		value, option,angle;
} thinglist_t;

#define	THINGNAME	"ThingInspector"

#define	DIFF_EASY	0
#define DIFF_NORMAL	1
#define DIFF_HARD	2
#define DIFF_ALL	3

@interface ThingPanel:Object
{
	id	fields_i;
 	id	window_i;
	id	addButton_i;
	id	updateButton_i;
	id	nameField_i;
	id	thingBrowser_i;
	id	thingColor_i;
	id	thingAngle_i;
	id	masterList_i;
	id	iconField_i;
	id	ambush_i;		// switch
	id	network_i;		// switch
	id	difficulty_i;	// switch matrix
	id	diffDisplay_i;	// radio matrix
	id	count_i;		// display count
	
	int	diffDisplay;
	
	worldthing_t	basething, oldthing;
}

- changeDifficultyDisplay:sender;
- (int)getDifficultyDisplay;
- emptyThingList;
- pgmTarget;
- menuTarget:sender;
- saveFrame;
- formTarget: sender;
- updateInspector: (BOOL)force;
- updateThingInspector;
- updateThingData:sender;
- sortThings;
- setAngle:sender;
- (NXColor)getThingColor:(int)type;
- fillThingData:(thinglist_t *)thing;
- fillDataFromThing:(thinglist_t *)thing;
- fillAllDataFromThing:(thinglist_t *)thing;
- addThing:sender;
- (int)findThing:(char *)string;
- (thinglist_t *)getThingData:(int)index;
- chooseThing:sender;
- confirmCorrectNameEntry:sender;
- getThing:(worldthing_t	*)thing;
- setThing:(worldthing_t *)thing;
- (int)searchForThingType:(int)type;
- suggestNewType:sender;
- scrollToItem:(int)which;
- getThingList;

- verifyIconName:sender;
- assignIcon:sender;
- unlinkIcon:sender;
- selectThingWithIcon:(char *)name;

- (thinglist_t *)getCurrentThingData;
- currentThingCount;

- (BOOL) readThing:(thinglist_t *)thing	from:(FILE *)stream;
- writeThing:(thinglist_t *)thing	from:(FILE *)stream;
- updateThingsDSP:(FILE *)stream;

@end
                                                                                                                                                                                                                                     #import	"Remapper.h"
#import <appkit/appkit.h>

extern	id	thingRemapper_i;

@interface ThingRemapper:Object <Remapper>
{
	id	remapper_i;
}

- menuTarget:sender;
- addToList:(char *)orgname to:(char *)newname;

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
#import <appkit/appkit.h>

typedef struct
{
	int		value;
	char		desc[32];
} thingstrip_t;

#define	THINGSTRIPNAME	"ThingStripper"

@interface ThingStripper:Object
{
	id	thingBrowser_i;		// nib outlets
	id	thingStripPanel_i;

	id	thingList_i;
}

- displayPanel:sender;
- addThing:sender;
- deleteThing:sender;
- doStrippingAllMaps:sender;
- doStrippingOneMap:sender;

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
#import "ThingPalette.h"
#import	"DoomProject.h"
#import	"TextureEdit.h"
#import	"Wadfile.h"
#import	"lbmfunctions.h"

id	thingPalette_i;

@implementation ThingPalette


//============================================================
//
//	Initialization
//
//============================================================
- init
{
	thingPalette_i = self;
	thingImages = window_i = NULL;
	currentIcon = -1;
	return self;
}

//============================================================
//
//	Menu target
//
//============================================================
- menuTarget:sender
{
	if (![thingImages	count])
	{
		NXRunAlertPanel("Nope!",
			"You haven't grabbed any icons!","OK",NULL,NULL);
		return self;
	}

	if (!window_i)
	{
		[NXApp 
			loadNibSection:	"ThingPalette.nib"
			owner:			self
			withNames:		NO
		];
		
		[window_i	setDelegate:self];
		[self		computeThingDocView];
		[nameField_i	setStringValue:""];
	}

	[window_i	makeKeyAndOrderFront:self];
	
	return self;
}

//============================================================
//
//	Find icon from name.  Returns index or -1 if not found.
//
//============================================================
- (int)findIcon:(char *)name
{
	int		i;
	int		max;
	icon_t	*icon;
	
	max = [thingImages	count];
	for (i = 0;i < max;i++)
	{
		icon = [thingImages	elementAt:i];
		if (!strcasecmp(icon->name,name))
			return i;
	}
	
	return -1;
}

//============================================================
//
//	Return icon data
//
//============================================================
- (icon_t *)getIcon:(int)which
{
	return [thingImages	elementAt:which];
}

//============================================================
//
//	Return currently selected icon #
//
//============================================================
- (int)getCurrentIcon
{
	return currentIcon;
}

//============================================================
//
//	Set currently selected icon #
//
//============================================================
- setCurrentIcon:(int)which
{
	icon_t	*icon;
	NXRect	r;
	
	if (which < 0)
		return self;
		
	currentIcon = which;
	icon = [thingImages	elementAt:which];
	[nameField_i		setStringValue:icon->name];
	r = icon->r;
	r.origin.y -= SPACING;
	r.size.height += SPACING*2;
	[thingPalView_i		scrollRectToVisible:&r];
	[thingPalScrView_i	display];
	return self;
}

//============================================================
//
//	Return amount of icons available
//
//============================================================
- (int)getNumIcons
{
	return [thingImages	count];
}

//============================================================
//
//	Dump all icons
//
//============================================================
- dumpAllIcons
{
	int		i;
	int		max;
	icon_t	*icon;
	
	max = [thingImages	count];
	for (i = 0; i < max; i++)
	{
		icon = [thingImages	elementAt:i];
		if (icon->image != NULL)
			free(icon->image);
	}
	[thingImages	empty];
	
	return self;
}

//============================================================
//
//	Set coords for all icons in the thingPalView
//
//============================================================
- computeThingDocView
{
	NXRect	dvr;
	int		i;
	int		x;
	int		y;
	int		max;
	icon_t	*icon;
	int		maxwidth;
	NXPoint	p;
	
	[thingPalScrView_i	getDocVisibleRect:&dvr];
	max = [thingImages	count];
	maxwidth = ICONSIZE*5 + SPACING*5;

	//
	//	Calculate the size of docView we're gonna need... 
	//
	x = y = SPACING;
	for (i = 0; i < max; i++)
	{
		icon = [thingImages	elementAt:i];
		
		if (icon->image == NULL)
		{
			x = SPACING;
			y += ICONSIZE + ICONSIZE/2 + SPACING*2;
			continue;
		}
		
		if (x > maxwidth)
		{
			x = SPACING;
			y += ICONSIZE + SPACING;
		}
		x += ICONSIZE + SPACING;
	}
	
	[thingPalView_i	sizeTo:dvr.size.width	:y];
	p.x = 0;
	p.y = y + ICONSIZE + SPACING;
	x = SPACING;

	//
	//	The docView has been resized. Now go and reorder all
	//	the flats from top to bottom...
	//
	for (i = 0; i < max; i++)
	{
		icon = [thingImages	elementAt:i];
		if (icon->image == NULL)
		{
			x = SPACING;
			y -= ICONSIZE + SPACING;
			icon->r.origin.x = x;
			icon->r.origin.y = y;
			y -= ICONSIZE/2 + SPACING;
			continue;
		}
		
		if (x > maxwidth )
		{
			x = SPACING;
			y -= ICONSIZE + SPACING;
		}
		icon->r.origin.x = x;
		icon->r.origin.y = y;
		x += ICONSIZE + SPACING;
	}
	
	[thingPalView_i	scrollPoint:&p ];

	return self;
}

//==========================================================
//
//	Load in and init thingImages
//
//==========================================================
- initIcons
{
	int		start;
	int		end;
	int		i;
	unsigned short	shortpal[256];
	unsigned char 	*palLBM;
	patch_t	*iconvga;
	icon_t	icon;
//	id		panel;
	
#if 0
	panel = NXGetAlertPanel("One moment...",
			"Loading icons for Thing Palette.",NULL,NULL,NULL);
	[panel	orderFront:NULL];
	[panel	flushWindow];
	NXPing();
#endif
	
	//
	//	Get palette and convert to 16-bit
	//
	palLBM = [wadfile_i	loadLumpNamed:"playpal"];
	if (palLBM == NULL)
		IO_Error ("Need to have 'playpal' palette in .WAD file!");
	LBMpaletteTo16 (palLBM, shortpal);

	thingImages = [[Storage	alloc]
				initCount:		0
				elementSize:	sizeof(icon_t)
				description:	NULL];
		
	//
	// get inclusive lump #'s for patches
	//
	start = [wadfile_i	lumpNamed:"icon_sta"] + 1;
	end = [wadfile_i	lumpNamed:"icon_end"];
	[doomproject_i	initThermo:"One moment..."
		message:"Loading icons for Thing Palette."];

	if  (start == -1 || end == -1 )
	{
		[doomproject_i	closeThermo];
		return self;		// no icons, no problem.
	}
			
	for (i = start; i < end; i++)
	{
		[doomproject_i	updateThermo:i-start max:end-start];
		//
		// load icon patch255 and convert to an NXImage
		//
		bzero(&icon,sizeof(icon));
		iconvga = [wadfile_i	loadLump:i];
		strcpy(icon.name,[wadfile_i	lumpname:i]);
		icon.name[8] = 0;
		strupr(icon.name);
		if (!strncmp(icon.name,"I-",2))
		{
			[thingImages	addElement:&icon];
			free(iconvga);
			continue;
		}

		icon.image = patchToImage(iconvga,shortpal,&icon.imagesize,icon.name);
		icon.r.size.width = ICONSIZE;
		icon.r.size.height = ICONSIZE;
		[thingImages	addElement:&icon];
		free(iconvga);
	}
	
	free(palLBM);
	[doomproject_i	closeThermo];
	
	return 0;
}

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ing, &oldthing, sizeof(basething)) )
	{
		memcpy (&oldthing, &basething, sizeof(oldthing));
		[self updateInspector: NO];
	}
			
	return self;
}	


/*
===================
=
= windowDidUpdate:
=
===================
*/

- windowDidUpdate:sender
{
	[self updateInspector: YES];
		
	return self;
}


@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #import "PreferencePanel.h"
#import "MapWindow.h"
#import "EditWorld.h"
#import "ThingPanel.h"
#import	"ThingPalette.h"
#import	"ThingWindow.h"
#import	"TextureEdit.h"		// for strupr()

id	thingpanel_i;

@implementation ThingPanel

/*
=====================
=
= init
=
=====================
*/

- init
{
	thingpanel_i = self;
	window_i = NULL;		// until nib is loaded
	masterList_i = [[Storage	alloc]
			initCount:		0
			elementSize:	sizeof(thinglist_t)
			description:	NULL];
			
	diffDisplay = DIFF_ALL;
	
	return self;
}

- emptyThingList
{
	[masterList_i	empty];
	return self;
}

/*
==============
=
= menuTarget:
=
==============
*/

- menuTarget:sender
{
	if (!window_i)
	{
		[NXApp 
			loadNibSection:	"thing.nib"
			owner:			self
			withNames:		NO
		];
		[window_i	setFrameUsingName:THINGNAME];
		[window_i	setDelegate:self];
		[thingBrowser_i	reloadColumn:0];
		[diffDisplay_i	selectCellAt:diffDisplay :0];
		[count_i	setStringValue:" "];
		[window_i	setParent:self];
	}

	[window_i makeKeyAndOrderFront:self];

	return self;
}

- windowDidMiniaturize:sender
{
	[sender	setMiniwindowIcon:"DoomEd"];
	[sender	setMiniwindowTitle:"Things"];
	return self;
}


- saveFrame
{
	if (window_i)
		[window_i	saveFrameUsingName:THINGNAME];
	return self;
}

- pgmTarget
{
	if (!window_i)
		[self	menuTarget:NULL];
	else
		[window_i	orderFront:NULL];
	return self;
}

- (thinglist_t *)getCurrentThingData
{
	thinglist_t		thing;
	
	if (!fields_i)
	{
		NXBeep();
		return NULL;
	}
		
	thing.value = [fields_i		intValueAt:1];
	strcpy(thing.name,[nameField_i stringValue]);
	strcpy(thing.iconname,[iconField_i	stringValue]);

	return &thing;
}

//===================================================================
//
//	Report the difficulty of Things to view
//
//===================================================================
- (int)getDifficultyDisplay
{
	return diffDisplay;
}

//===================================================================
//
//	Change the difficulty of Things to view
//
//===================================================================
- changeDifficultyDisplay:sender
{
	id				cell;
	
	//
	//	Handle redrawing Edit windows for diff. change
	//
	cell = [sender selectedCell];
	diffDisplay = [cell tag];
	[editworld_i	redrawWindows];
	[self	currentThingCount];
	
	return self;
}

//===================================================================
//
//	Display # of Things that match currently selected type
//
//===================================================================
- currentThingCount
{
	int				max;
	int				j;
	thinglist_t		*t;
	worldthing_t	*thing;
	int				count;

	//
	//	Count up how many of currently selected Thing there is
	//
	if (diffDisplay == DIFF_ALL)
	{
		[count_i	setStringValue:"-"];
		return self;
	}
		
	max = [masterList_i	count];
	t = [self	getCurrentThingData];
	count = 0;
	thing = &things[0];

	for (j = 0;j < numthings; j++,thing++)
		if (t->value == thing->type)
		{
			if ((thing->options&1)-1 == diffDisplay)
				count++;
			else
			if (((thing->options&2)-1) == diffDisplay )
				count++;
			else
			if (((thing->options&4)-2) == diffDisplay )
				count++;
		}

	[count_i	setIntValue:count];
	
	return self;
}

//===================================================================
//
//	Select the Thing that has icon "name"
//
//===================================================================
- selectThingWithIcon:(char *)name
{
	int				max;
	int				i;
	thinglist_t		*t;
	id				matrix;
	
	max = [masterList_i	count];
	for (i = 0;i < max; i++)
	{
		t = [masterList_i	elementAt:i];
		if (!strcasecmp(t->iconname,name))
		{
			[self	fillDataFromThing:t];
			matrix = [thingBrowser_i	matrixInColumn:0];
			[matrix	selectCellAt:i :0];
			[matrix	scrollCellToVisible:i :0];
			return self;
		}
	}
	
	return self;
}

//===================================================================
//
//	Unlink icon from this Thing
//
//===================================================================
- unlinkIcon:sender
{
	[iconField_i	setStringValue:"NOICON"];
	[updateButton_i	performClick:self];
	return self;
}

//===================================================================
//
//	Assign icon selected in Thing Palette to current thing data
//
//===================================================================
- assignIcon:sender
{
	int		iconnum;
	icon_t	*icon;
	
	iconnum = [thingPalette_i	getCurrentIcon];
	if (iconnum < 0)
	{
		NXBeep();
		return self;
	}
	icon = [thingPalette_i	getIcon:iconnum];
	[iconField_i	setStringValue:icon->name];
	[updateButton_i	performClick:self];
	
	return self;
}

//===================================================================
//
//	Verify a correct icon name input
//
//===================================================================
- verifyIconName:sender
{
	char	name[10];
	int		which;
	
	strcpy(name,[iconField_i	stringValue]);
	strupr(name);
	which = [thingPalette_i	findIcon:name];
	if (which < 0)
	{
		NXBeep();
		[iconField_i	setStringValue:"NOICON"];
		return self;
	}
	[iconField_i	setStringValue:name];
	
	return self;
}

//===================================================================
//
//	Suggest a new type for a new Thing
//
//===================================================================
- suggestNewType:sender
{
	int	num,i,found,max;
	
	max = [masterList_i	count];
	for (num = 1;num < 10000;num++)
	{
		found = 0;
		for (i = 0;i < max;i++)
			if (((thinglist_t *)[masterList_i	elementAt:i])->value == num)
			{
				found = 1;
				break;
			}
		if (!found)
		{
			[fields_i	setIntValue:num	at:1];
			return self;
		}
	}
	return self;
}

//
// delegate method called by "thingBrowser_i"
//
- (int)browser:sender  fillMatrix:matrix  inColumn:(int)column
{
	int	max, i;
	id	cell;
	thinglist_t		*t;
	
	if (column > 0)
		return 0;
		
	[self	sortThings];
	max = [masterList_i	count];
	for (i = 0; i < max; i++)
	{
		t = [masterList_i	elementAt:i];
		[matrix	insertRowAt:i];
		cell = [matrix	cellAt:i	:0];
		[cell	setStringValue:t->name];
		[cell setLeaf: YES];
		[cell setLoaded: YES];
		[cell setEnabled: YES];
	}
	return max;
}

//
// sort the thing list
//
- sortThings
{
	id	cell, matrix;
	int	max,i,j,flag, which;
	thinglist_t		*t1, *t2, tt1, tt2;
	char		name[32] = "\0";
	
	cell = [thingBrowser_i	selectedCell];
	if (cell)
		strcpy(name,[cell	stringValue]);
	max = [masterList_i	count];
	
	do
	{
		flag = 0;
		for (i = 0;i < max; i++)
		{
			t1 = [masterList_i	elementAt:i];
			for (j = i + 1;j < max;j++)
			{
				t2 = [masterList_i	elementAt:j];
				if (strcasecmp(t2->name,t1->name) < 0)
				{
					tt1 = *t1;
					tt2 = *t2;
					[masterList_i	replaceElementAt:j  with:&tt1];
					[masterList_i	replaceElementAt:i  with:&tt2];
					flag = 1;
					break;
				}
			}
		}
	} while(flag);
	
	which = [self	findThing:name];
	if (which >= 0)
	{
		matrix = [thingBrowser_i	matrixInColumn:0];
		[matrix	selectCellAt:which  :0];
		[matrix	scrollCellToVisible:which :0];
	}			
	
	return self;
}

//
// update current thing with current data
//
- updateThingData:sender
{
	id	cell;
	int	which;
	thinglist_t		*t;
	
	cell = [thingBrowser_i		selectedCell];
	if (!cell)
	{
		NXBeep();
		return self;
	}
	which = [self	findThing:(char *)[cell	stringValue]];
	t = [masterList_i	elementAt:which];
	[self	fillThingData:t];
	[thingBrowser_i	reloadColumn:0];
	[[thingBrowser_i	matrixInColumn:0]
					selectCellAt:which  :0];
	[doomproject_i	setDirtyProject:TRUE];
	
	return self;
}

//
// take data from input fields and update thing data
//
- fillThingData:(thinglist_t *)thing
{
	thing->angle = [fields_i		intValueAt:0];
	thing->value = [fields_i		intValueAt:1];
	[self	confirmCorrectNameEntry:NULL];
	strcpy(thing->name,[nameField_i	stringValue]);
	thing->option = [ambush_i	intValue]<<3;
	thing->option |= ([network_i	intValue]&1)<<4;
	thing->option |= [[difficulty_i cellAt:0 :0] intValue]&1;
	thing->option |= ([[difficulty_i cellAt:1 :0] intValue]&1)<<1;
	thing->option |= ([[difficulty_i cellAt:2 :0] intValue]&1)<<2;
	thing->color = [thingColor_i	color];
	strcpy(thing->iconname,[iconField_i	stringValue]);
	if (!thing->iconname[0])
		strcpy(thing->iconname,"NOICON");
	return self;
}

//
// corrects any wrongness in namefield
//
- confir#import	"EditWorld.h"
#import	"ThingPanel.h"
#import	"ThingRemapper.h"

id	thingRemapper_i;

@implementation ThingRemapper
//===================================================================
//
//	REMAP FLATS IN MAP
//
//===================================================================
- init
{
	thingRemapper_i = self;
	
	remapper_i = [ [ Remapper	alloc ]
				setFrameName:"ThingRemapper"
				setPanelTitle:"Thing Remapper"
				setBrowserTitle:"List of things to be remapped"
				setRemapString:"Thing"
				setDelegate:self ];
	return self;
}

//===================================================================
//
//	Bring up panel
//
//===================================================================
- menuTarget:sender
{
	[remapper_i	showPanel];
	return self;
}

- addToList:(char *)orgname to:(char *)newname;
{
	[remapper_i	addToList:orgname to:newname];
	return self;
}

//===================================================================
//
//	Delegate methods
//
//===================================================================
- (char *)getOriginalName
{
	thinglist_t	*t;
	
	t = [thingpanel_i	getCurrentThingData];
	if (t == NULL)
		return NULL;
	return t->name;
}

- (char *)getNewName
{
	thinglist_t	*t;
	
	t = [thingpanel_i	getCurrentThingData];
	if (t == NULL)
		return NULL;
	return t->name;
}

- (int)doRemap:(char *)oldname to:(char *)newname
{
	int	i, thingnum,oldnum,newnum;
	thinglist_t	*t;
	
	t = [thingpanel_i	getThingData:[thingpanel_i	findThing:oldname]];
	oldnum = t->value;
	t = [thingpanel_i	getThingData:[thingpanel_i	findThing:newname]];
	newnum = t->value;
	thingnum = 0;
	
	for (i = 0;i < numthings; i++)
	{
		if (things[i].type == oldnum)
		{
			things[i].type = newnum;
			thingnum++;
		}
	}
	
	return thingnum;
}

- finishUp
{
	[editworld_i	redrawWindows];
	return self;
}

@end
                                                                                                                                                                                                                         #import	"ThingPanel.h"
#import	"ThingStripper.h"

@implementation ThingStripper
//=====================================================================
//
//	Thing Stripper
//
//=====================================================================

//===================================================================
//
//	Load the .nib (if needed) and display the panel
//
//===================================================================
- displayPanel:sender
{
	if (!thingStripPanel_i)
	{
		[NXApp 
			loadNibSection:	"ThingStripper.nib"
			owner:			self
			withNames:		NO
		];
		[thingStripPanel_i	setFrameUsingName:THINGSTRIPNAME];
		[thingStripPanel_i	setDelegate:self];

		thingList_i = [[Storage	alloc]
				initCount:		0
				elementSize:	sizeof(thingstrip_t)
				description:	NULL];
	}
	[thingBrowser_i	reloadColumn:0];
	[thingStripPanel_i	makeKeyAndOrderFront:NULL];
	return self;
}

- windowDidMiniaturize:sender
{
	[sender	setMiniwindowIcon:"DoomEd"];
	[sender	setMiniwindowTitle:"ThingStrip"];
	return self;
}

//
//	Empty list if window gets closed!
//
- windowWillClose:sender
{
	[thingStripPanel_i	saveFrameUsingName:THINGSTRIPNAME];
	[thingList_i	empty];
	return self;
}

//===================================================================
//
//	Do actual Thing stripping from all maps
//
//===================================================================
- doStrippingOneMap:sender
{
	int		k,j;
	int		listMax;
	thingstrip_t	*ts;
	
	listMax = [thingList_i	count];
	if (!listMax)
		return self;
	
	//
	//	Strip all things in list
	//
	for (k = 0;k < numthings;k++)
		for (j = 0;j < listMax; j++)
		{
			ts = [thingList_i	elementAt:j];
			if (ts->value == things[k].type)
				things[k].selected = -1;
		}

	[editworld_i	redrawWindows];
	[doomproject_i	setDirtyMap:TRUE];
	
	return self;
}

//===================================================================
//
//	Do actual Thing stripping from all maps
//
//===================================================================
- doStrippingAllMaps:sender
{
	int		k,j;
	int		listMax;
	thingstrip_t	*ts;
	
	listMax = [thingList_i	count];
	if (!listMax)
		return self;
	
	[editworld_i	closeWorld];
	[doomproject_i	beginOpenAllMaps];
	
	while ([doomproject_i	openNextMap] == YES);
	{
		//
		//	Strip all things in list
		//
		for (k = 0;k < numthings;k++)
			for (j = 0;j < listMax; j++)
			{
				ts = [thingList_i	elementAt:j];
				if (ts->value == things[k].type)
					things[k].selected = -1;
			}

		[doomproject_i	saveDoomEdMapBSP:NULL];
	}
	return self;
}

//===================================================================
//
//	Delete thing from Thing Stripping Panel
//
//===================================================================
- deleteThing:sender
{
	id	matrix;
	int	selRow;
	
	matrix = [thingBrowser_i	matrixInColumn:0];
	selRow = [matrix	selectedRow];
	if (selRow >= 0)
	{
		[matrix	removeRowAt:selRow andFree:YES];
		[thingList_i	removeElementAt:selRow];
	}
	[matrix	sizeToCells];
	[matrix	selectCellAt:-1 :-1];
	[thingBrowser_i	reloadColumn:0];

	return self;
}

//===================================================================
//
//	Add thing in Thing Panel to this list
//
//===================================================================
- addThing:sender
{
	thinglist_t		*t;
	thingstrip_t	ts;

	t =[thingpanel_i	getCurrentThingData];
	if (t == NULL)
	{
		NXBeep();
		return self;
	}
	ts.value = t->value;
	strcpy(ts.desc,t->name);
	[thingList_i	addElement:&ts];
	[thingBrowser_i	reloadColumn:0];
	return self;
}

//===================================================================
//
//	Delegate method called by "thingBrowser_i" when reloadColumn is invoked
//
//===================================================================
- (int)browser:sender  fillMatrix:matrix  inColumn:(int)column
{
	int	max, i;
	id	cell;
	thingstrip_t	*t;
	
	if (column > 0)
		return 0;
		
	max = [thingList_i	count];
	for (i = 0; i < max; i++)
	{
		t = [thingList_i	elementAt:i];
		[matrix	insertRowAt:i];
		cell = [matrix	cellAt:i	:0];
		[cell	setStringValue:t->desc];
		[cell setLeaf: YES];
		[cell setLoaded: YES];
		[cell setEnabled: YES];
	}
	return max;
}

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
#import <appkit/appkit.h>

@interface ThingWindow:Window
{
	id	parent_i;
	char	string[32];
}

- setParent:(id)p;


@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       mCorrectNameEntry:sender
{
	char		name[32];
	int	i;

	bzero(name,32);
	if (strlen([nameField_i	stringValue]) > 31)
		strncpy(name,[nameField_i	stringValue],31);
	else
		strcpy(name,[nameField_i	stringValue]);
		
	for (i = 0; i < strlen(name);i++)
		if (name[i] == ' ')
			name[i] = '_';
	[nameField_i	setStringValue:name];
	return self;
}

//
// fill-in the information for a worldthing_t
//
- getThing:(worldthing_t	*)thing
{
	thing->angle = [fields_i	intValueAt:0];
	thing->type = [fields_i	intValueAt:1];
	thing->options = [ambush_i	intValue]<<3;
	thing->options |= ([network_i	intValue]&1)<<4;
	thing->options |= [[difficulty_i	cellAt:0 :0] intValue]&1;
	thing->options |= ([[difficulty_i	cellAt:1 :0] intValue]&1)<<1;
	thing->options |= ([[difficulty_i	cellAt:2 :0] intValue]&1)<<2;
	
	return self;
}

//
// user selected a thing in the map; reflect the selection in the thingpanel
//
- setThing:(worldthing_t *)thing
{
	int	which;
	thinglist_t		*t;
	
	which = [self	searchForThingType:thing->type];
	if (which >= 0)
	{
		t = [masterList_i	elementAt:which];
		t->option = thing->options;
		t->angle = thing->angle;
		
		[self	fillAllDataFromThing:t];
		[self	scrollToItem:which];
		[thingPalette_i	setCurrentIcon:[thingPalette_i	findIcon:t->iconname]];
	}
	
	return self;
}

- getThingList
{
	return masterList_i;
}

- scrollToItem:(int)which
{
	id	matrix;
	
	matrix = [thingBrowser_i	matrixInColumn:0];
	[matrix	selectCellAt:which :0];
	[matrix	scrollCellToVisible:which :0];
	return self;
}

- setAngle:sender
{
	[fields_i setIntValue:[[sender	selectedCell]	tag] at:0];
	[self		formTarget:NULL];
	return self;
}

- (NXColor)getThingColor:(int)type
{
	int	index;
	
	index = [self  searchForThingType:type];
	if (index < 0)
		return [prefpanel_i colorFor: SELECTED_C];
	return	((thinglist_t *)[masterList_i	elementAt:index])->color;
}

//
// you know the thing's type, but don't know the name!
//
- (int)searchForThingType:(int)type
{
	int	max,i;
	thinglist_t		*t;
	
	max = [masterList_i	count];
	for (i = 0;i < max;i++)
	{
		t = [masterList_i	elementAt:i];
		if (t->value == type)
			return i;
	}
	return -1;
}

//
// fill data from thing
//
- fillDataFromThing:(thinglist_t *)thing
{
	[fields_i	setIntValue:thing->value	at:1];
	[nameField_i	setStringValue:thing->name];
	[thingColor_i	setColor:thing->color];
	[iconField_i	setStringValue:thing->iconname];
	
	basething.type = thing->value;
	
	return self;
}

//
// fill ALL data from thing
//
- fillAllDataFromThing:(thinglist_t *)thing
{
	[self	fillDataFromThing:thing];
	
	[fields_i	setIntValue:thing->angle	at:0];
	[ambush_i	setIntValue:((thing->option)>>3)&1];
	[network_i	setIntValue:((thing->option)>>4)&1];
	[[difficulty_i cellAt:0 :0] setIntValue:(thing->option)&1];
	[[difficulty_i cellAt:1 :0] setIntValue:((thing->option)>>1)&1];
	[[difficulty_i cellAt:2 :0] setIntValue:((thing->option)>>2)&1];
	
	basething.angle = thing->angle;
	basething.options = thing->option;
	
	return self;
}

//
// Add "type" to thing list
//
- addThing:sender
{
	thinglist_t		t;
	int	which;
	id	matrix;

	[self	fillThingData:&t];
	
	//
	// check for duplicate name
	//
	if ([self	findThing:t.name] >= 0)
	{
		NXBeep();
		NXRunAlertPanel("Oops!",
			"You already have a THING by that name!","OK",NULL,NULL,NULL);
		return self;
	}
	
	[masterList_i	addElement:&t];
	[thingBrowser_i	reloadColumn:0];
	which = [self	findThing:t.name];
	matrix = [thingBrowser_i	matrixInColumn:0];
	[matrix	selectCellAt:which :0];
	[matrix	scrollCellToVisible:which :0];
	[doomproject_i	setDirtyProject:TRUE];
	
	return self;
}

#if 0
//
// delete thing from list.
// Data in "name" and "type" must match element in list.
//
- delThing:sender
{
	int	which;
	
	if ((which = [self	findThing:(char *)[nameField_i  stringValue]]) != -1)
	{
		[masterList_i	removeElementAt:which];
		[thingBrowser_i	reloadColumn:0];
	}
	return self;
}
#endif

//
// return index of thing in masterList. "string" is used for search thru list.
//
- (int)findThing:(char *)string
{
	int	max, i;
	thinglist_t		*t;
	
	max = [masterList_i	count];
	for (i = 0;i < max; i++)
	{
		t = [masterList_i	elementAt:i];
		if (!strcasecmp(t->name,string))
			return i;
	}
	return -1;
}

- (thinglist_t *)getThingData:(int)index
{
	return [masterList_i	elementAt:index];		
}

//
// user chose an item in the thingBrowser_i.
// stick the info in the "name" and "type" fields.
//
- chooseThing:sender
{
	id		cell;
	int		which;
	thinglist_t		*t;
	
	cell = [sender	selectedCell];
	if (!cell)
		return self;
		
	which = [self	findThing:(char *)[cell	stringValue]];
	if (which < 0)
	{
		NXBeep();
		printf("Whoa! Can't find that thing!\n");
		return self;
	}

	t = [masterList_i	elementAt:which];
	[self	fillDataFromThing:t];
	[self	formTarget:NULL];
	which = [thingPalette_i	findIcon:t->iconname];
	if (which >= 0)
		[thingPalette_i	setCurrentIcon:which];
	return self;
}

- (BOOL) readThing:(thinglist_t *)thing	from:(FILE *)stream
{
	float	r,g,b;
	
	if (fscanf(stream,"%s = %d %d %d (%f %f %f) %s\n",
			thing->name,&thing->angle,&thing->value,&thing->option,
			&r,&g,&b,thing->iconname) != 8)
		return NO;
	thing->color = NXConvertRGBToColor(r,g,b);
	return YES;
}

- writeThing:(thinglist_t *)thing	from:(FILE *)stream
{
	float	r,g,b;
	
	NXConvertColorToRGB(thing->color,&r,&g,&b);
	fprintf(stream,"%s = %d %d %d (%f %f %f) %s\n",thing->name,thing->angle,thing->value,
			thing->option,r,g,b,thing->iconname);
	return self;
}

//
// update the things.dsp file (when project is saved/loaded)
//
- updateThingsDSP:(FILE *)stream
{
	thinglist_t		t,*t2;
	int	count, i, found;
	
	//
	// read things out of the file, only adding new things to the current list
	//
	if (fscanf (stream, "numthings: %d\n", &count) == 1)
	{
		for (i = 0; i < count; i++)
		{
			[self	readThing:&t	from:stream];
			found = [self	findThing:t.name];
			if (found < 0)
			{
				[masterList_i	addElement:&t];
				[doomproject_i	setDirtyProject:TRUE];
			}
		}
		[thingBrowser_i	reloadColumn:0];

		//
		// now, write out the new file!
		//
		count = [masterList_i	count];
		fseek (stream, 0, SEEK_SET);
		fprintf (stream, "numthings: %d\n",count);
		for (i = 0; i < count; i++)
		{
			t2 = [masterList_i	elementAt:i];
			[self	writeThing:t2	from:stream];
		}
	}
	else
		fprintf(stream,"numthings: %d\n",0);
	
	return self;
}
	
/*
==============
=
= updateInspector
=
= call with force == YES to update into a window while it is off screen, otherwise
= no updating is done if not visible
=
==============
*/

- updateInspector: (BOOL)force
{
	if (!force && ![window_i isVisible])
		return self;

	[window_i disableFlushWindow];
	
	[fields_i setIntValue: basething.angle at: 0];
	[fields_i setIntValue: basething.type at: 1];
	[ambush_i	setIntValue:((basething.options)>>3)&1];
	[network_i	setIntValue:((basething.options)>>4)&1];
	[[difficulty_i	cellAt:0 :0] setIntValue:(basething.options)&1];
	[[difficulty_i	cellAt:1 :0] setIntValue:((basething.options)>>1)&1];
	[[difficulty_i	cellAt:2 :0] setIntValue:((basething.options)>>2)&1];
	
	[window_i reenableFlushWindow];
	[window_i flushWindow];
	
	return self;
}

/*
==============
=
= formTarget:
=
= The user has edited something in a form cell
=
==============
*/

- formTarget: sender
{
	int			i;
	worldthing_t	*thing;
	
	basething.angle = [fields_i intValueAt: 0];
	basething.type = [fields_i intValueAt: 1];
	basething.options = [ambush_i	intValue]<<3;
	basething.options |= ([network_i	intValue]&1)<<4;
	basething.options |= [[difficulty_i cellAt:0 :0] intValue]&1;
	basething.options |= ([[difficulty_i cellAt:1 :0] intValue]&1)<<1;
	basething.options |= ([[difficulty_i cellAt:2 :0] intValue]&1)<<2;
	
	thing = &things[0];
	for (i=0 ; i<numthings ; i++, thing++)
		if (thing->selected > 0)
		{
			thing->angle = basething.angle;
			thing->type = basething.type;
			thing->options = basething.options;
			[editworld_i changeThing: i to: thing];
			[doomproject_i	setDirtyMap:TRUE];
		}
		
	
	return self;
}


/*
==============
=
= updateThingInspector
=
==============
*/

- updateThingInspector
{
	int			i;
	worldthing_t	*thing;
	
	thing = &things[0];
	for (i=0 ; i<numthings ; i++, thing++)
		if (thing->selected > 0)
		{
			basething = *thing;
			break;
		}
		
	if (bcmp (&baseth#import	"ThingPanel.h"
#import "ThingWindow.h"
#import	"TextureEdit.h"

@implementation ThingWindow

- setParent:(id)p
{
	parent_i = p;
	return self;
}

//===================================================================
//
//	Match keypress to first letter
//
//===================================================================
- keyDown:(NXEvent *)event
{
	char	key[2];
	char	string2[32];
	int		max;
	int		i;
	thinglist_t	*t;
	id		thingList_i;
	int		found;
	int		size;
	int		tries;
	
	key[0] = event->data.key.charCode;
	strupr(key);
	strcat(string,key);
	size = strlen(string);
		
	thingList_i = [parent_i  getThingList];
	max = [thingList_i	count];
	tries = 2;
	
	while(tries)
	{
		found = 0;
		
		for (i = 0;i < max; i++)
		{
			t = [thingList_i	elementAt:i];
			strcpy(string2,t->name);
			strupr(string2);
				
			if (!strncmp(string,string2,size))
			{
				[parent_i	scrollToItem:i];
				found = 1;
				tries = 0;
				break;
			}
		}
		
		if (!found)
		{
			string[0] = key[0];
			string[1] = 0;
			strupr(string);
			size = 1;
			tries--;
		}
	}
	
	return self;
}

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /* 
Timing.h

This class implements a simple interval timer to aid in measuring drawing performance.  It'll measure either wall or CPU time spent within an interval delineated by a pair of messages to the Timing object.  It's most useful in situations where you need to measure not only the time spent within the process, but also the time spent in other processes, most notably the Window Server.  CPU time includes process time, system time on behalf of the process, and Window Server time on behalf of the process.  The results are most accurate if averaged over a number of passes through the interval, and the Timing object will keep track of:  number of times entered, cumulative elapsed time, and average elapsed time.

Use the +newWithTag: method to create a Timing object.

Use the -reset message to reset the Timing object before entering the timing interval for the first time.

A timing interval is delineated by an -enter: message and a -leave message.  enter: takes a single argument that specifies either WALLTIME or PSTIME.

Use the -summary: method to have the Timing object print out a summary to the stream that is passed in as the argument to summary:.  Alternatively, the Timing object provides methods for querying it for the appropriate values.

Here's an example of its use.  

    - action4:sender
    {
        int i=100;
        id t4 = [Timing newWithTag:4];
        [t4 reset];
        [self lockFocus];
        while(i--){
        [t4 enter:PSTIME];
        [self drawCachedLines];
        [[self window ] flushWindow];
        [t4 leave];
        }
    [self unlockFocus];
        [t4 summary:stream];
        [self addSummary];
        return self;
    }

*/

#import <objc/Object.h>
#include <sys/time.h>
#import <sys/resource.h>
#define PSTIME 0
#define WALLTIME 1

@interface Timing : Object
{
    struct timezone tzone;
    struct timeval realtime;
    struct rusage rtime;
    double synctime;
    int    stime;
    double cumWallTime;      /* cum. wall time app + server */
    double cumAppTime;       /* cum. app process + system time */
    double cumPSTime;        /* cum. Server time on behalf of the app */
    double avgWallTime;      /* (cum. wall time app + server)/
                                cumTimesEntered */
    double avgAppTime;       /* (cum. app process + system time)/
                                cumTimesEntered */
    double avgPSTime;        /* (cum. Server time on behalf of the 
                                app)/cumTimesEntered */
    double tare;             /* used to account for ipc overhead */
    int    cumTimesEntered;  /* number of times timing interval entered 
                                since last reset */
    int    tag;              /* identifies timer object */
    int    wallTime;         /* flag to specify whether wall or process 
                                time is desired */
}

+newWithTag:(int) aTag;
    /* Creates a new timing object with tag = aTag */

-enter:(int)wt;
    /* Starts a timing interval measuring either elapsed wall time if 
       wt ==WALLTIME or elapsed process time + system time + Server time 
       if wt == PSTIME.  Sets the wallTime flag to be equal to wt. */

-wallEnter;
    /* Called by enter: if WALLTIME is desired.  You should call enter: 
       rather than call this method directly. */

-psEnter;
    /* Called by enter: if PSTIME is desired.  You should call enter: 
       rather than call this method directly. */

-wallLeave;
    /* Called by leave if WALLTIME was specified on the previous enter.  
       You should call leave rather than call this method directly.  
       Updates cumWallTime based on the elapsed time. */

-psLeave;
    /* Called by leave if PSTIME was specified on the previous enter.  
       You should call leave rather than call this method directly.  
       Updates cumPSTime and cumAppTime based on the elapsed time. */

-leave;
    /* Call leave to leave a timing interval.  Depending on whether 
       WALLTIME or PSTIME was specified on the previous call to enter:, 
       leave will invoke wallLeave or psLeave. */

-reset;
    /* Resets the values of cumWallTime, cumPSTime, cumAppTime, 
       cumTimesEntered and other variables to 0 in preparation for 
       measuring a series of timing intervals.  Should be called prior to 
       running a timing test. */

-avgElapsedTime;
    /* Calculates averages.  Called automatically by summary:. */

-summary:(NXStream *)c;
    /* Writes out a summary to the stream pointed to by c.  Depending on 
       the current value of wallTime will write out a summary for either 
       wall time or ps time. */

-(double) cumWallTime;
    /* Returns cumWallTime if wallTime == WALLTIME, -1 otherwise. */

-(double) cumAppTime;
    /* Returns cumAppTime if wallTime == PSTIME, -1.0 otherwise.  
       cumAppTime represents the cumulative time spent in the process and 
       system calls made by the process.  It does not include time spent 
       in the Server. */

-(double) cumPSTime;
    /* Returns cumPSTime if wallTime == PSTIME, -1.0 otherwise.  
       cumPSTime represents the cumulative time spent in the Window 
       Server on the behalf of the process. */

@end

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /* Timing.m */

#import "Timing.h"
#import <stdio.h>
#import <streams/streams.h>
#import <dpsclient/wraps.h>
#import <appkit/graphics.h>

@implementation Timing

+newWithTag:(int) aTag
{
    self = [super new];
    tag = aTag;
    [self reset];
    return self;
}

-enter:(int)wt
{
    if(wallTime = (wt==WALLTIME))
    [self wallEnter];
    else
    [self psEnter];
    return self;
}

-wallEnter
{
    cumTimesEntered++;
    NXPing();
    gettimeofday(&realtime,&tzone);
    synctime = realtime.tv_sec + realtime.tv_usec/1000000.0;
    return self;
}

-tare
{
    struct timezone tzone1;
    struct timeval realtime1;
    struct timeval realtime2;
    NXPing();
    gettimeofday(&realtime1,&tzone1);
    NXPing();
    gettimeofday(&realtime2,&tzone1);
    tare = (-realtime1.tv_sec + realtime2.tv_sec)+ 
            (-realtime1.tv_usec+realtime2.tv_usec)/1000000.0;
    return self;
}

-psEnter
{
    cumTimesEntered++;
    PSusertime(&stime);
    getrusage(RUSAGE_SELF,&rtime);
    synctime = (rtime.ru_utime.tv_sec + rtime.ru_stime.tv_sec) +
                (rtime.ru_utime.tv_usec + rtime.ru_stime.tv_usec)/1000000.0;
    return self;
}

-wallLeave
{
    double eTime;
    NXPing();
    gettimeofday(&realtime,&tzone);
    eTime = (- synctime + realtime.tv_sec + realtime.tv_usec/1000000.0) 
                -tare;
    cumWallTime += eTime;
    return self;
}

-psLeave
{
    int et;
    double appTime;
    double psTime;
    getrusage(RUSAGE_SELF,&rtime);
    PSusertime(&et);
    psTime = ((et-stime)/1000.0);
    cumPSTime += psTime;
    appTime  = ((rtime.ru_utime.tv_sec + rtime.ru_stime.tv_sec) +
                (rtime.ru_utime.tv_usec + 
                rtime.ru_stime.tv_usec)/1000000.0) -synctime;
    cumAppTime += appTime;
    return self;
}

-leave
{
    if(wallTime)
    [self wallLeave];
    else
    [self psLeave];
    return self;
}

-reset
{
    cumAppTime = 0.0;
    cumPSTime = 0.0;
    cumWallTime = 0.0;
    cumTimesEntered = 0;
    return self;
}

-avgElapsedTime
{
    if(wallTime)
        avgWallTime = (cumWallTime/(double)cumTimesEntered);
    else{
        avgAppTime = (cumAppTime/(double)cumTimesEntered) ;
        avgPSTime = (cumPSTime/(double)cumTimesEntered);
    }
    return self;
}

-(double) cumWallTime
{
    if(wallTime ==WALLTIME)
    return cumWallTime;
    else
    return -1.0;
}

-(double) cumAppTime;
{
    if(wallTime ==PSTIME)
    return cumAppTime;
    else
    return -1.0;
}

-(double) cumPSTime;
{
    if(wallTime ==PSTIME)
    return cumPSTime;
    else
    return -1.0;
}

-summary:(NXStream *)c
{
    if(wallTime) {
    NXPrintf(c,"Timer %d : entered %d trials TotalWall Time  %lf \n",
    tag,cumTimesEntered, cumWallTime);
    }
    else {
    NXPrintf(c,"Timer %d : %d trials App: %lf  Server: %lf  Percent Server: %lf Total: %lf\n\00", 
                tag,cumTimesEntered,cumAppTime,cumPSTime,
                cumPSTime/(cumAppTime+cumPSTime),
                cumAppTime+cumPSTime);
    }
    NXFlush(c);
    return self;
}

@end


                                                                         
#import <appkit/appkit.h>

typedef enum
{
	SELECT_TOOL = 0,
	POLY_TOOL,
	LINE_TOOL,
	ZOOMIN_TOOL,
	SLIDE_TOOL,
	GET_TOOL,
	THING_TOOL,
	LAUNCH_TOOL
} tool_t;

extern	id	toolpanel_i;

@interface ToolPanel:Object
{
    id	toolmatrix_i;
}

- toolChanged:sender;
- (tool_t)currentTool;
- changeTool:(int)which;

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #import	"ThingPanel.h"
#import "ToolPanel.h"

id	toolpanel_i;

@implementation ToolPanel

- init
{
	toolpanel_i = self;
	return self;
}

- toolChanged:sender
{
	switch([self	currentTool])
	{
		case THING_TOOL:
			[thingpanel_i	pgmTarget];
		default:
			break;
	}
    return self;
}

- (tool_t)currentTool
{
	return [toolmatrix_i selectedRow];
}

- changeTool:(int)which
{
	[toolmatrix_i	selectCellAt:which :0];
	return self;
}


@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              MM *   J*P8$BJL 
P ( `P !pr!cqh<jUGbm7@@                                                                B                     (               
  ' 
  '                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #import <appkit/appkit.h>


@interface Wadfile : Object
{
	int		handle;
	char		*pathname;
	id		info;
	BOOL	dirty;
}

- initFromFile: (char const *)path;
- initNew: (char const *)path;
- close;
- free;

- (int)numLumps;
- (int)lumpsize: (int)lump;
- (int)lumpstart: (int)lump;
- (char const *)lumpname: (int)lump;
- (int)lumpNamed: (char const *)name;
- (void *)loadLump: (int)lump;
- (void *)loadLumpNamed: (char const *)name;

- addName: (char const *)name data: (void *)data size: (int)size;
- writeDirectory; 

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         MM *             p  p?/?p        pp                          *                                         2      :       (       R                
  ' 
  '                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #import "Wadfile.h"
#import "idfunctions.h"
#import <ctype.h>

typedef struct
{
	char		identification[4];		// should be IWAD
	int		numlumps;
	int		infotableofs;
} wadinfo_t;


typedef struct
{
	int		filepos;
	int		size;
	char		name[8];
} lumpinfo_t;


@implementation Wadfile

//=============================================================================

/*
============
=
= initFromFile:
=
============
*/

- initFromFile: (char const *)path
{
	wadinfo_t	wad;
	lumpinfo_t	*lumps;
	int			i;
	
	pathname = malloc(strlen(path)+1);
	strcpy (pathname, path);
	dirty = NO;
	handle = open (pathname, O_RDWR, 0666);
	if (handle== -1)
	{
		[self free];
		return nil;
	}
//
// read in the header
//
	read (handle, &wad, sizeof(wad));
	if (strncmp(wad.identification,"IWAD",4))
	{
		close (handle);
		[self free];
		return nil;
	}
	wad.numlumps = LongSwap (wad.numlumps);
	wad.infotableofs = LongSwap (wad.infotableofs);
	
//
// read in the lumpinfo
//
	lseek (handle, wad.infotableofs, L_SET);
	info = [[Storage alloc] initCount: wad.numlumps elementSize: sizeof(lumpinfo_t) description: ""];
	lumps = [info elementAt: 0];
	
	read (handle, lumps, wad.numlumps*sizeof(lumpinfo_t));
	for (i=0 ; i<wad.numlumps ; i++, lumps++)
	{
		lumps->filepos = LongSwap (lumps->filepos);
		lumps->size = LongSwap (lumps->size);
	}
	
	return self;
}


/*
============
=
= initNew:
=
============
*/

- initNew: (char const *)path
{
	wadinfo_t	wad;

	pathname = malloc(strlen(path)+1);
	strcpy (pathname, path);
	info = [[Storage alloc] initCount: 0 elementSize: sizeof(lumpinfo_t) description: ""];
	dirty = YES;
	handle = open (pathname, O_CREAT | O_TRUNC | O_RDWR, 0666);
	if (handle== -1)
		return nil;
// leave space for wad header
	write (handle, &wad, sizeof(wad));
	
	return self;
}

-close
{
	close (handle);
	return self;
}

-free
{
	close (handle);
	[info free];
	free (pathname);
	return [super free];
}

//=============================================================================

- (int)numLumps
{
	return [info count];
}

- (int)lumpsize: (int)lump
{
	lumpinfo_t	*inf;
	inf = [info elementAt: lump];
	return inf->size;
}

- (int)lumpstart: (int)lump
{
	lumpinfo_t	*inf;
	inf = [info elementAt: lump];
	return inf->filepos;
}

- (char const *)lumpname: (int)lump
{
	lumpinfo_t	*inf;
	inf = [info elementAt: lump];
	return inf->name;
}

/*
================
=
= lumpNamed:
=
================
*/

- (int)lumpNamed: (char const *)name
{
	lumpinfo_t	*inf;
	int			i, count;
	char			name8[9];
	int			v1,v2;

// make the name into two integers for easy compares

	memset(name8,0,9);
	if (strlen(name) < 9)
		strncpy (name8,name,9);
	for (i=0 ; i<9 ; i++)
		name8[i] = toupper(name8[i]);	// case insensitive

	v1 = *(int *)name8;
	v2 = *(int *)&name8[4];


// scan backwards so patch lump files take precedence

	count = [info count];
	for (i=count-1 ; i>=0 ; i--)
	{
		inf = [info elementAt: i];
		if ( *(int *)inf->name == v1 && *(int *)&inf->name[4] == v2)
			return i;
	}
	return  -1;
}

/*
================
=
= loadLump:
=
================
*/

- (void *)loadLump: (int)lump
{
	lumpinfo_t	*inf;
	byte			*buf;
	
	inf = [info elementAt: lump];
	buf = malloc (inf->size);
	
	lseek (handle, inf->filepos, L_SET);
	read (handle, buf, inf->size);
	
	return buf;
}

- (void *)loadLumpNamed: (char const *)name
{
	return [self loadLump:[self lumpNamed: name]];
}

//============================================================================

/*
================
=
= addName:data:size:
=
================
*/

- addName: (char const *)name data: (void *)data size: (int)size
{
	int		i;
	lumpinfo_t	new;
	
	dirty = YES;
	memset (new.name,0,sizeof(new.name));
	strncpy (new.name, name, 8);
	for (i=0 ; i<8 ; i++)
		new.name[i] = toupper(new.name[i]);
	new.filepos = lseek(handle,0, L_XTND);
	new.size = size;
	[info addElement: &new];
	
	write (handle, data, size);
	
	return self;
}


/*
================
=
= writeDirectory:
=
	char		identification[4];		// should be IWAD
	int		numlumps;
	int		infotableofs;
================
*/

- writeDirectory
{
	wadinfo_t	wad;
	int			i,count;
	lumpinfo_t	*inf;
	
//
// write the directory
//
	count = [info count];
	inf = [info elementAt:0];
	for (i=0 ; i<count ; i++)
	{
		inf[i].filepos = LongSwap (inf[i].filepos);
		inf[i].size = LongSwap (inf[i].size);
	}
	wad.infotableofs = LongSwap (lseek(handle,0, L_XTND));
	write (handle, inf, count*sizeof(lumpinfo_t));
	for (i=0 ; i<count ; i++)
	{
		inf[i].filepos = LongSwap (inf[i].filepos);
		inf[i].size = LongSwap (inf[i].size);
	}
	
//
// write the header
//
	strncpy (wad.identification, "IWAD",4);
	wad.numlumps = LongSwap ([info count]);
	lseek (handle, 0, L_SET);
	write (handle, &wad, sizeof(wad));
	
	return self;
}

@end

                                                                                                                                                                                                                                                                                                                                                                                                                                    MM *             ??p  ?o_/?_?/O?p?_?  ??      p                          *                                         2      :       (       R                
  ' 
  '                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              cp *.m $1
cp *.h $1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #import <appkit/appkit.h>

#ifndef __BYTEBOOL__
#define __BYTEBOOL__
typedef unsigned char byte;
typedef enum {false, true} boolean;
#endif

typedef struct
{
	float	left, bottom, right, top;
} box_t;

void BoxFromRect (box_t *box, NXRect *rect);
void BoxFromPoints (box_t *box, NXPoint *p1, NXPoint *p2);

void IDRectFromPoints( NXRect *rect, NXPoint const *p1, NXPoint const *p2 );
void IDEnclosePoint (NXRect *rect, NXPoint const *point);

unsigned short ShortSwap (unsigned short dat);
unsigned LongSwap (unsigned dat);
int filelength (int handle);
int tell (int handle);

void BackupFile (char const *fname);

void DefaultExtension (char *path, char *extension);
void DefaultPath (char *path, char *basepath);

void StripExtension (char *path);
void StripFilename (char *path);
void ExtractFileName (char *path, char *dest);

void IdException (char const *format, ...);
                                                                                                                                                      =s2style:4,0,4;backing:4,4,2;\ buttonMask:4,6,3;visible:4,9,1;isMainWindow:4,10,1;\ isKeyWindow:4,11,1;isPanel:4,12,1;hideOnDeactivate:4,13,1;\ dontFreeWhenClosed:4,14,1;oneShot:4,15,1;; _wFlags2:T169=s2deferred:4,0,1;_cursorRectsDisabled:4,1,1;\ _haveFreeCursorRects:4,2,1;_validCursorRects:4,3,1;\ docEdited:4,4,1;dynamicDepthLimit:4,5,1;\ _worksWhenModal:4,6,1;_limitedBecomeKey:4,7,1;\ _needsFlush:4,8,1;_newMiniIcon:4,9,1;_ignoredFirstMouse:4,10,1;\ _repostedFirstMouse:4,11,1;_windowDying:4,12,1;\ _tempHidden:4,13,1;_hiddenOnDeactivate:4,14,1;\ _floatingPanel:4,15,1;; Window:T170=s100isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;contentView:/190,224,32;\ delegate:/190,256,32;firstResponder:/190,288,32;\ lastLeftHit:/190,320,32;lastRightHit:/190,352,32;\ counterpart:/190,384,32;fieldEditor:/190,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1168,544,16;wFlags2:/1169,560,16;\ _borderView:/190,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1171=*122,672,32;_invalidCursorView:/190,704,32;\ _miniIcon:/190,736,32;_private:/172,768,32;; __vFlags:T172=s2noClip:4,0,1;translatedDraw:4,1,1;\ drawInSuperview:4,2,1;alreadyFlipped:4,3,1;\ needsFlipped:4,4,1;rotatedFromBase:4,5,1;\ rotatedOrScaledFromBase:4,6,1;opaque:4,7,1;\ disableAutodisplay:4,8,1;needsDisplay:4,9,1;\ validGState:4,10,1;newGState:4,11,1;_RESERVED:4,12,2;\ _noVerticalAutosizing:4,14,1;_hasDirtySubview:4,15,1;; ___vFlags:T173=s2autosizing:4,0,6;autoresizeSubviews:4,6,1;\ notifyWhenFlipped:4,7,1;ancestorNotifyWasEnabled:4,8,1;\ needsAncestorNotify:4,9,1;notifyToInitGState:4,10,1;\ wantsGState:4,11,1;noCopyOnScroll:4,12,1;\ noDisplayOnScroll:4,13,1;specialClip:4,14,1;\ mark:4,15,1;; View:T174=s80isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;bounds:/1137,224,128;\ superview:/190,352,32;subviews:/190,384,32;window:/190,416,32;\ vFlags:/1172,448,16;_vFlags:/1173,464,16;_gState:/11,480,32;\ _frameMatrix:/190,512,32;_drawMatrix:/190,544,32;\ _dragTypes:/1145,576,32;_vPrivate:/172,608,32;; _conFlags:T175=s2enabled:4,0,1;editingValid:4,1,1;\ ignoreMultiClick:4,2,1;calcSize:4,3,1;_drawingAncestor:4,4,1;\ _RESERVED:4,5,11;; Control:T176=s92isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;bounds:/1137,224,128;\ superview:/190,352,32;subviews:/190,384,32;window:/190,416,32;\ vFlags:/1172,448,16;_vFlags:/1173,464,16;_gState:/11,480,32;\ _frameMatrix:/190,512,32;_drawMatrix:/190,544,32;\ _dragTypes:/1145,576,32;_vPrivate:/172,608,32;tag:/11,640,32;\ cell:/190,672,32;conFlags:/1175,704,16;_reservedCshort1:/19,720,16;; Button:T177=s92isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;bounds:/1137,224,128;\ superview:/190,352,32;subviews:/190,384,32;window:/190,416,32;\ vFlags:/1172,448,16;_vFlags:/1173,464,16;_gState:/11,480,32;\ _frameMatrix:/190,512,32;_drawMatrix:/190,544,32;\ _dragTypes:/1145,576,32;_vPrivate:/172,608,32;tag:/11,640,32;\ cell:/190,672,32;conFlags:/1175,704,16;_reservedCshort1:/19,720,16;; _bmap:T178=s8normal:90,0,32;alternate:90,32,32;; _ke:T179=s8font:90,0,32;descent:12,32,32;; _icon:T180=u8bmap:178,0,64;ke:179,0,64;; _bcFlags1:T181=s2pushIn:4,0,1;changeContents:4,1,1;\ changeBackground:4,2,1;changeGray:4,3,1;\ lightByContents:4,4,1;lightByBackground:4,5,1;\ lightByGray:4,6,1;hasAlpha:4,7,1;bordered:4,8,1;\ iconOverlaps:4,9,1;horizontal:4,10,1;bottomOrLeft:4,11,1;\ iconAndText:4,12,1;lastState:4,13,1;iconSizeDiff:4,14,1;\ iconIsKeyEquivalent:4,15,1;; _bcFlags2:T182=s2keyEquivalent:4,0,8;transparent:4,8,1;\ _RESERVED:4,9,4;_inset:4,13,2;_momentarySound:4,15,1;; ButtonCell:T183=s60isa:/187,0,32;contents:/120,32,32;\ support:/190,64,32;cFlags1:/1138,96,16;cFlags2:/1139,112,16;\ _cFlags3:/1140,128,16;_reservedCshort:/19,144,16;\ tag:/11,160,32;target:/190,192,32;action:/191,224,32;\ _view:/190,256,32;altContents:/120,288,32;icon:/1180,320,64;\ sound:/190,384,32;bcFlags1:/1181,416,16;bcFlags2:/1182,432,16;\ periodicDelay:/19,448,16;periodicInterval:/19,464,16;; Panel:T184=s100isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;contentView:/190,224,32;\ delegate:/190,256,32;firstResponder:/190,288,32;\ lastLeftHit:/190,320,32;lastRightHit:/190,352,32;\ counterpart:/190,384,32;fieldEditor:/190,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1168,544,16;wFlags2:/1169,560,16;\ _borderView:/190,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1171,672,32;_invalidCursorView:/190,704,32;\ _miniIcon:/190,736,32;_private:/172,768,32;; ChoosePrinter:T185=s156isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;contentView:/190,224,32;\ delegate:/190,256,32;firstResponder:/190,288,32;\ lastLeftHit:/190,320,32;lastRightHit:/190,352,32;\ counterpart:/190,384,32;fieldEditor:/190,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1168,544,16;wFlags2:/1169,560,16;\ _borderView:/190,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1171,672,32;_invalidCursorView:/190,704,32;\ _miniIcon:/190,736,32;_private:/172,768,32;appIcon:/190,800,32;\ ok:/190,832,32;cancel:/190,864,32;border:/190,896,32;\ exitTag:/11,928,32;name:/190,960,32;type:/190,992,32;\ note:/190,1024,32;_lastValues:/1186=*95,1056,32;accessoryView:/190,1088,32;\ _reservedChoosePrinter1:/14,1120,32;_reservedChoosePrinter2:/14,1152,32;\ _reservedChoosePrinter3:/14,1184,32;_reservedChoosePrinter4:/14,1216,32;; NXCharMetrics:Tt187=s32charCode:8,0,16;numKernPairs:11,16,8;\ reserved:11,24,8;xWidth:12,32,32;name:1,64,32;\ bbox:188=ar1;0;3;12,96,128;kernPairIndex:1,224,32;; NXLigature:Tt189=s12firstCharIndex:1,0,32;secondCharIndex:1,32,32;\ ligatureIndex:1,64,32;; NXEncodedLigature:Tt190=s4firstChar:11,0,8;secondChar:11,8,8;\ ligatureChar:11,16,8;reserved:11,24,8;; NXKernPair:Tt191=s12secondCharIndex:1,0,32;dx:12,32,32;\ dy:12,64,32;; NXKernXPair:Tt192=s8secondCharIndex:1,0,32;dx:12,32,32;; NXTrackKern:Tt193=s20degree:1,0,32;minPointSize:12,32,32;\ minKernAmount:12,64,32;maxPointSize:12,96,32;\ maxKernAmount:12,128,32;; NXCompositeChar:Tt194=s12compCharIndex:1,0,32;numParts:1,32,32;\ firstPartIndex:1,64,32;; NXCompositeCharPart:Tt195=s12partIndex:1,0,32;dx:12,32,32;\ dy:12,64,32;; _NXFontMetrics:T196=s164formatVersion:20,0,32;name:20,32,32;\ fullName:20,64,32;familyName:20,96,32;weight:20,128,32;\ italicAngle:12,160,32;isFixedPitch:2,192,8;isScreenFont:2,200,8;\ screenFontSize:8,208,16;fontBBox:188,224,128;underlinePosition:12,352,32;\ underlineThickness:12,384,32;version:20,416,32;\ notice:20,448,32;encodingScheme:20,480,32;capHeight:12,512,32;\ xHeight:12,544,32;ascender:12,576,32;descender:12,608,32;\ hasYWidths:8,640,16;widths:197=*12,656,32;widthsLength:4,688,32;\ strings:20,720,32;stringsLength:4,752,32;hasXYKerns:2,784,8;\ reserved:2,792,8;encoding:198=*8,800,32;yWidths:197,832,32;\ charMetrics:199=*187,864,32;numCharMetrics:1,896,32;\ ligatures:200=*189,928,32;numLigatures:1,960,32;\ encLigatures:201=*190,992,32;numEncLigatures:1,1024,32;\ kerns:202=u4kernPairs:203=*191,0,32;kernXPairs:204=*192,0,32;;,1056,32;\ numKernPairs:1,1088,32;trackKerns:205=*193,1120,32;\ numTrackKerns:1,1152,32;compositeChars:206=*194,1184,32;\ numCompositeChars:1,1216,32;compositeCharParts:207=*195,1248,32;\ numCompositeCharParts:1,1280,32;; NXFontMetrics:Tt196 NXFontTraitMask:t4 _fmFlags:T208=s2multipleFont:4,0,1;disabled:4,1,1;\ _RESERVED:4,2,14;; FontManager:T209=s48isa:/187,0,32;panel:/190,32,32;\ menu:/190,64,32;action:/191,96,32;whatToDo:/11,128,32;\ traitToChange:/14,160,32;selFont:/190,192,32;fmFlags:/1208,224,16;\ _lastPos:/19,240,16;delegate:/190,256,32;_reservedFMint2:/14,288,32;\ _reservedFMint3:/14,320,32;_reservedFMint4:/14,352,32;; _fpFlags:T210=s2multipleFont:4,0,1;dirty:4,1,1;\ _RESERVED:4,2,11;_amPreviewing:4,13,1;_alwaysPreview:4,14,1;\ _dontPreview:4,15,1;; FontPanel:T211=s184isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;contentView:/190,0000000000000000;0777777777777777777777; long long unsigned int:t7=r1;0000000000000;01777777777777777777777; short int:t8=r1;-32768;32767; short unsigned int:t9=r1;0;65535; signed char:t10=r1;-128;127; unsigned char:t11=r1;0;255; float:t12=r1;4;0; double:t13=r1;8;0; long double:t14=r1;12;0; complex int:t15=s8real:1,0,32;imag:1,32,32;; complex float:t16=r16;4;0; complex double:t17=r17;8;0; complex long double:t18=r18;12;0; void:t19=19 va_list:t20=*2 _iobuf:T21=s20_cnt:1,0,32;_ptr:20,32,32;\ _base:20,64,32;_bufsiz:1,96,32;_flag:8,128,16;\ _file:11,144,8;_smallbuf:2,152,8;;  :T22=edps_ascii:0,dps_binObjSeq:1,dps_encodedTokens:2,; DPSProgramEncoding:t22  :T23=edps_indexed:0,dps_strings:1,; DPSNameEncoding:t23  :T24=edps_tBoolean:0,dps_tChar:1,dps_tUChar:2,\ dps_tFloat:3,dps_tDouble:4,dps_tShort:5,\ dps_tUShort:6,dps_tInt:7,dps_tUInt:8,\ dps_tLong:9,dps_tULong:10,; DPSDefinedType:t24  :T25=edps_machServer:0,dps_fdServer:1,dps_stream:2,; DPSContextType:t25 DPSResultsRec:t26=s12type:24,0,32;count:1,32,32;\ value:20,64,32;; DPSResults:t27=*26 DPSSpaceRec:t28=s8lastNameIndex:1,0,32;procs:29=*30=xs_t_DPSSpaceProcsRec:,32,32;; DPSSpace:t31=*28 _t_DPSSpaceProcsRec:T30=s4DestroySpace:32=*33=f19,0,32;; DPSSpaceProcsRec:t30 DPSSpaceProcs:t34=*30 _t_DPSContextRec:T35=s48priv:20,0,32;space:31,32,32;\ programEncoding:22,64,32;nameEncoding:23,96,32;\ procs:36=*37=xs_t_DPSProcsRec:,128,32;textProc:38=*39=f19,160,32;\ errorProc:38,192,32;resultTable:27,224,32;resultTableLength:4,256,32;\ chainParent:40=*35,288,32;chainChild:40,320,32;\ type:25,352,32;; DPSContextRec:t35 DPSContext:t40 _t_DPSProcsRec:T37=s56BinObjSeqWrite:41=*42=f19,0,32;\ WriteTypedObjectArray:43=*44=f19,32,32;WriteStringChars:45=*46=f19,64,32;\ WriteData:41,96,32;WritePostScript:41,128,32;FlushContext:47=*48=f19,160,32;\ ResetContext:47,192,32;UpdateNameMap:47,224,32;\ AwaitReturnValues:47,256,32;Interrupt:47,288,32;\ DestroyContext:47,320,32;WaitContext:47,352,32;\ Printf:49=*50=f19,384,32;WriteNumString:51=*52=f19,416,32;; DPSProcsRec:t37 DPSProcs:t53=*37 NXCoord:t12 _NXPoint:T54=s8x:12,0,32;y:12,32,32;; NXPoint:t54 _NXSize:T55=s8width:12,0,32;height:12,32,32;; NXSize:t55 NXEventData:t56=u12mouse:57=s12reserved:8,0,16;\ eventNum:8,16,16;click:1,32,32;pressure:11,64,8;\ reserved1:2,72,8;reserved2:8,80,16;;,0,96;\ key:58=s12reserved:8,0,16;repeat:8,16,16;\ charSet:9,32,16;charCode:9,48,16;keyCode:9,64,16;\ keyData:8,80,16;;,0,96;tracking:59=s12reserved:8,0,16;\ eventNum:8,16,16;trackingNum:1,32,32;userData:1,64,32;;,0,96;\ compound:60=s12reserved:8,0,16;subtype:8,16,16;\ misc:61=u8F:62=ar1;0;1;12,0,64;L:63=ar1;0;1;3,0,64;\ S:64=ar1;0;3;8,0,64;C:65=ar1;0;7;2,0,64;;,32,64;;,0,96;; _NXEvent:T66=s40type:1,0,32;location:54,32,64;\ time:3,96,32;flags:1,128,32;window:4,160,32;\ data:56,192,96;ctxt:40,288,32;; NXEvent:t66 NXEventPtr:t67=*66 integer_t:t1 port_name_t:t1 port_t:t1 _NXStream:T68=s40magic_number:4,0,32;buf_base:69=*11,32,32;\ buf_ptr:69,64,32;buf_size:1,96,32;buf_left:1,128,32;\ offset:3,160,32;flags:1,192,32;eof:1,224,32;\ functions:70=*71=xsstream_functions:,256,32;info:72=*19,288,32;; NXStream:t68 stream_functions:T71=s28read_bytes:73=*74=f1,0,32;\ write_bytes:75=*76=f1,32,32;flush_buffer:77=*78=f1,64,32;\ fill_buffer:77,96,32;change_buffer:79=*80=f19,128,32;\ seek:81=*82=f19,160,32;destroy:79,192,32;; DPSTimedEntry:t83=*84=xs__DPSTimedEntry: Class:t85=*86=xsobjc_class: objc_object:T87=s4isa:85,0,32;; id:t88=*87 SEL:t89=*90=xsobjc_selector: IMP:t91=*92=f88 BOOL:t2 objc_class:T86=s40isa:85,0,32;super_class:85,32,32;\ name:93=*2,64,32;version:3,96,32;info:3,128,32;\ instance_size:3,160,32;ivars:94=*95=xsobjc_ivar_list:,192,32;\ methods:96=*97=xsobjc_method_list:,224,32;cache:98=*99=xsobjc_cache:,256,32;\ protocols:100=*101=xsobjc_protocol_list:,288,32;; Ivar:t102=*103=xsobjc_ivar: objc_ivar:T103=s12ivar_name:20,0,32;ivar_type:20,32,32;\ ivar_offset:1,64,32;; objc_ivar_list:T95=s16ivar_count:1,0,32;ivar_list:104=ar1;0;0;103,32,96;; Method:t105=*106=xsobjc_method: objc_method:T106=s12method_name:89,0,32;method_types:20,32,32;\ method_imp:91,64,32;; objc_method_list:T97=s20method_next:96,0,32;method_count:1,32,32;\ method_list:107=ar1;0;0;106,64,96;; objc_protocol_list:T101=s12next:100,0,32;count:1,32,32;\ list:108=ar1;0;0;109=*110=xsProtocol:,64,32;; objc_cache:T99=s12mask:4,0,32;occupied:4,32,32;\ buckets:111=ar1;0;0;105,64,32;; Object:T112=s4isa:/185,0,32;; NXHashTablePrototype:Tt113=s16hash:114=*115=f4,0,32;isEqual:116=*117=f1,32,32;\ free:118=*119=f19,64,32;style:1,96,32;; NXHashTable:Tt120=s20prototype:121=*113,0,32;count:4,32,32;\ nbBuckets:4,64,32;buckets:72,96,32;info:122=*19,128,32;; NXAtom:t93 HashTable:T123=s24isa:/185,0,32;count:/14,32,32;\ keyDesc:/193,64,32;valueDesc:/193,96,32;_nbBuckets:/14,128,32;\ _buckets:/172,160,32;; List:T124=s16isa:/185,0,32;dataPtr:125=*88,32,32;\ numElements:4,64,32;maxElements:4,96,32;; objc_method_description:T126=s8name:89,0,32;types:20,32,32;; objc_method_description_list:T127=s12count:1,0,32;list:128=ar1;0;0;126,32,64;; Protocol:T110=s20isa:/185,0,32;protocol_name:/020,32,32;\ protocol_list:/0100,64,32;instance_methods:/0129=*127,96,32;\ class_methods:/0129,128,32;; Storage:T130=s24isa:/185,0,32;dataPtr:72,32,32;\ description:93,64,32;numElements:4,96,32;maxElements:4,128,32;\ elementSize:4,160,32;; _NXColor:T131=s16colorField:132=ar1;0;5;9,0,96;\ str:93,96,32;; NXColor:Tt131 _NXRect:T133=s16origin:54,0,64;size:55,64,64;; NXRect:Tt133 Responder:T134=s12isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;; Pasteboard:T135=s56isa:/185,0,32;owner:/188,32,32;\ _realChangeCount:/11,64,32;_ourChangeCount:/11,96,32;\ _server:/11,128,32;_ownerArray:/1125,160,32;_numTypes:/11,192,32;\ _typesArray:/1136=*93,224,32;_client:/11,256,32;\ _typesProvided:/1137=*2,288,32;_name:/193,320,32;\ _host:/193,352,32;_serverVersion:/11,384,32;_reservedPasteboard4:/14,416,32;; __appFlags:T138=s2hidden:4,0,1;autoupdate:4,1,1;\ active:4,2,1;_hasBeenRun:4,3,1;_RESERVED:4,4,7;\ _doingUnhide:4,11,1;_delegateReturnsValidRequestor:4,12,1;\ _deactPending:4,13,1;_invalidState:4,14,1;\ _invalidEvent:4,15,1;; Application:T139=s160isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;appName:/120,96,32;currentEvent:/166,128,320;\ windowList:/188,448,32;keyWindow:/188,480,32;mainWindow:/188,512,32;\ delegate:/188,544,32;hiddenList:/1140=*1,576,32;\ hiddenCount:/11,608,32;hostName:/193,640,32;context:/140,672,32;\ contextNum:/11,704,32;appListener:/188,736,32;\ appSpeaker:/188,768,32;replyPort:/11,800,32;screenSize:/155,832,64;\ running:/18,896,16;appFlags:/1138,912,16;_reservedApp4:/188,928,32;\ _focusStack:/188,960,32;_freelist:/188,992,32;_pboard:/188,1024,32;\ _mainMenu:/188,1056,32;_appIcon:/188,1088,32;_nameTable:/188,1120,32;\ _printInfo:/188,1152,32;_reservedApp1:/14,1184,32;\ _reservedApp2:/14,1216,32;_reservedApp3:/14,1248,32;; __imageFlags:T141=s2scalable:4,0,1;dataRetained:4,1,1;\ flipDraw:4,2,1;uniqueWindow:4,3,1;uniqueWasExplicitlySet:4,4,1;\ sizeWasExplicitlySet:4,5,1;builtIn:4,6,1;\ needsToExpand:4,7,1;useEPSOnResolutionMismatch:4,8,1;\ colorMatchPreferred:4,9,1;multipleResolutionMatching:4,10,1;\ dontFreeName:4,11,1;subImage:4,12,1;aSynch:4,13,1;\ archiveByName:4,14,1;unboundedCacheDepth:4,15,1;; NXImage:T142=s36isa:/185,0,32;name:/120,32,32;\ _size:/155,64,64;_flags:/1141,128,16;_reservedShort:/18,144,16;\ _reps:/172,160,32;_repList:/1143=*124,192,32;_color:/1144=*131,224,32;\ _reservedInt:/11,256,32;; _wFlags:T145=s2style:4,0,4;backing:4,4,2;\ buttonMask:4,6,3;visible:4,9,1;isMainWindow:4,10,1;\ isKeyWindow:4,11,1;isPanel:4,12,1;hideOnDeactivate:4,13,1;\ dontFreeWhenClosed:4,14,1;oneShot:4,15,1;; _wFlags2:T146=s2deferred:4,0,1;_cursorRectsDisabled:4,1,1;\ _haveFreeCursorRects:4,2,1;_validCursorRects:4,3,1;\ docEdited:4,4,1;dynamicDepthLimit:4,5,1;\ _worksWhenModal:4,6,1;_limitedBecomeKey:4,7,1;\ _needsFlush:4,8,1;_newMiniIcon:4,9,1;_ignoredFirstMouse:4,10,1;\ _repostedFirstMouse:4,11,1;_windowDying:4,12,1;\ _tempHidden:4,13,1;_hiddenOnDeactivate:4,14,1;\ _floatingPanel:4,15,1;; Window:T147=s100isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;contentView:/188,224,32;\ delegate:/188,256,32;firstResponder:/188,288,224,32;\ delegate:/190,256,32;firstResponder:/190,288,32;\ lastLeftHit:/190,320,32;lastRightHit:/190,352,32;\ counterpart:/190,384,32;fieldEditor:/190,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1168,544,16;wFlags2:/1169,560,16;\ _borderView:/190,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1171,672,32;_invalidCursorView:/190,704,32;\ _miniIcon:/190,736,32;_private:/172,768,32;faces:/190,800,32;\ families:/190,832,32;preview:/190,864,32;current:/190,896,32;\ size:/190,928,32;sizes:/190,960,32;manager:/190,992,32;\ selFont:/190,1024,32;selMetrics:/1212=*196,1056,32;\ curTag:/11,1088,32;accessoryView:/190,1120,32;_keyBuffer:/120,1152,32;\ setButton:/190,1184,32;separator:/190,1216,32;sizeTitle:/190,1248,32;\ lastPreview:/120,1280,32;fpFlags:/1210,1312,16;_reservedFPshort1:/19,1328,16;\ _lastKeyTime:/13,1344,32;_chooser:/190,1376,32;_titles:/190,1408,32;\ _previewBox:/190,1440,32;; FormCell:T213=s52isa:/187,0,32;contents:/120,32,32;\ support:/190,64,32;cFlags1:/1138,96,16;cFlags2:/1139,112,16;\ _cFlags3:/1140,128,16;_reservedCshort:/19,144,16;\ tag:/11,160,32;target:/190,192,32;action:/191,224,32;\ _view:/190,256,32;titleWidth:/112,288,32;titleCell:/190,320,32;\ titleEndPoint:/112,352,32;_reservedFCint1:/14,384,32;; Listener:T214=s40isa:/187,0,32;portName:/120,32,32;\ listenPort:/11,64,32;signaturePort:/11,96,32;\ delegate:/190,128,32;timeout:/11,160,32;priority:/11,192,32;\ _delegate2:/190,224,32;_requestDelegate:/190,256,32;\ _reservedListener2:/11,288,32;; _menuFlags:T215=s2sizeFitted:4,0,1;autoupdate:4,1,1;\ attached:4,2,1;tornOff:4,3,1;wasAttached:4,4,1;\ wasTornOff:4,5,1;_RESERVED:4,6,6;_templateType:4,12,2;\ _isServicesMenu:4,14,1;_changeTitle:4,15,1;; Menu:T216=s126isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;contentView:/190,224,32;\ delegate:/190,256,32;firstResponder:/190,288,32;\ lastLeftHit:/190,320,32;lastRightHit:/190,352,32;\ counterpart:/190,384,32;fieldEditor:/190,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1168,544,16;wFlags2:/1169,560,16;\ _borderView:/190,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1171,672,32;_invalidCursorView:/190,704,32;\ _miniIcon:/190,736,32;_private:/172,768,32;supermenu:/190,800,32;\ matrix:/190,832,32;attachedMenu:/190,864,32;lastLocation:/154,896,64;\ reserved:/190,960,32;menuFlags:/1215,992,16;; MenuCell:T217=s64isa:/187,0,32;contents:/120,32,32;\ support:/190,64,32;cFlags1:/1138,96,16;cFlags2:/1139,112,16;\ _cFlags3:/1140,128,16;_reservedCshort:/19,144,16;\ tag:/11,160,32;target:/190,192,32;action:/191,224,32;\ _view:/190,256,32;altContents:/120,288,32;icon:/1180,320,64;\ sound:/190,384,32;bcFlags1:/1181,416,16;bcFlags2:/1182,432,16;\ periodicDelay:/19,448,16;periodicInterval:/19,464,16;\ updateAction:/191,480,32;; NXBrowserCell:T218=s20isa:/187,0,32;contents:/120,32,32;\ support:/190,64,32;cFlags1:/1138,96,16;cFlags2:/1139,112,16;\ _cFlags3:/1140,128,16;_reservedCshort:/19,144,16;; _colorListFlags:T219=s2colorsLoaded:4,0,1;editable:4,1,1;\ hasDeviceSpecificLists:4,2,1;generatesNamedColors:4,3,1;\ dirty:4,4,1;hasFrozen:4,5,1;; NXColorList:T220=s50isa:/187,0,32;_name:/020,32,32;\ _printerType:/020,64,32;_fileName:/020,96,32;\ _hashTable:/090,128,32;_colors:/090,160,32;_delegate:/090,192,32;\ _editor:/090,224,32;_flags:/0219,256,16;_localNames:/090,272,32;\ _reserved:/0221=ar1;0;2;4,304,96;; NXColorPanel:T222=s164isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;contentView:/190,224,32;\ delegate:/190,256,32;firstResponder:/190,288,32;\ lastLeftHit:/190,320,32;lastRightHit:/190,352,32;\ counterpart:/190,384,32;fieldEditor:/190,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1168,544,16;wFlags2:/1169,560,16;\ _borderView:/190,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1171,672,32;_invalidCursorView:/190,704,32;\ _miniIcon:/190,736,32;_private:/172,768,32;_cpPrivate:/172,800,32;\ _reservedCPint:/1223=ar1;0;14;1,832,480;; _csrFlags:T224=s2onMouseExited:4,0,1;onMouseEntered:4,1,1;\ _RESERVED:4,2,14;; NXCursor:T225=s22isa:/187,0,32;hotSpot:/154,32,64;\ cFlags:/1224,96,16;image:/190,112,32;_reservedInt:/14,144,32;; NXDataLinkPanel:T226=s152isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;contentView:/190,224,32;\ delegate:/190,256,32;firstResponder:/190,288,32;\ lastLeftHit:/190,320,32;lastRightHit:/190,352,32;\ counterpart:/190,384,32;fieldEditor:/190,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1168,544,16;wFlags2:/1169,560,16;\ _borderView:/190,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1171,672,32;_invalidCursorView:/190,704,32;\ _miniIcon:/190,736,32;_private:/172,768,32;breakLink:/090,800,32;\ openSource:/090,832,32;updateDestination:/090,864,32;\ updateMode:/090,896,32;breakAllLinks:/090,928,32;\ showOutlines:/090,960,32;bannerMsg:/090,992,32;\ sourceTitle:/090,1024,32;sourceValue:/090,1056,32;\ lastUpdateTitle:/090,1088,32;lastUpdateValue:/090,1120,32;\ accessoryView:/090,1152,32;needsUpdate:/02,1184,8;\ reserved1:/02,1192,8;reserved2:/08,1200,16;; NXHelpPanel:T227=s104isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;contentView:/190,224,32;\ delegate:/190,256,32;firstResponder:/190,288,32;\ lastLeftHit:/190,320,32;lastRightHit:/190,352,32;\ counterpart:/190,384,32;fieldEditor:/190,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1168,544,16;wFlags2:/1169,560,16;\ _borderView:/190,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1171,672,32;_invalidCursorView:/190,704,32;\ _miniIcon:/190,736,32;_private:/172,768,32;private:/172,800,32;; SNDSoundStruct:Tt228=s28magic:1,0,32;dataLocation:1,32,32;\ dataSize:1,64,32;dataFormat:1,96,32;samplingRate:1,128,32;\ channelCount:1,160,32;info:229=ar1;0;3;2,192,32;; NXJournalHeader:Tt230=s20version:1,0,32;offsetToAppNames:4,32,32;\ lastEventTime:4,64,32;reserved1:4,96,32;reserved2:4,128,32;; NXJournaler:T231=s138isa:/187,0,32;_startTime:/13,32,32;\ _soundStatus:/11,64,32;_appsData:/190,96,32;\ _sndBuffer:/1232=*228,128,32;_soundfile:/120,160,32;\ _recordDevice:/11,192,32;_nextEvent:/166,224,320;\ _eventStream:/1233=*68,544,32;_teNum:/185,576,32;\ _journalHeader:/1230,608,160;_mouseDownWindow:/190,768,32;\ _mouseDownWindowNum:/11,800,32;_applicationNum:/11,832,32;\ _dragWindowNum:/11,864,32;_oldEventMask:/14,896,32;\ _oldEventFilter:/183,928,32;_pendingStop:/12,960,8;\ _listener:/190,976,32;_speaker:/190,1008,32;_delegate:/190,1040,32;\ _eventStatus:/11,1072,32;; timeval:T234=s8tv_sec:3,0,32;tv_usec:3,32,32;; NXPrinter:T235=s86isa:/187,0,32;printerName:/195,32,32;\ hostName:/195,64,32;domainName:/195,96,32;printerType:/195,128,32;\ _ignore:/12,160,8;_valid:/12,168,8;_creationNum:/11,176,32;\ _nodes:/172,208,32;_previousValid:/1234,240,64;_niInstance:/13,304,32;\ _priv:/172,336,32;reserved:/1236=ar1;0;9;72,368,320;; _spFlags:T237=s2opening:4,0,1;exitOk:4,1,1;\ allowMultiple:4,2,1;dirty:4,3,1;invalidateMatrices:4,4,1;\ filtered:4,5,1;_chooseFolders:4,6,1;_ignoreFilePackages:4,7,1;\ _largeFS:4,8,1;_delegateValidatesNew:4,9,1;\ _delegateValidatesOld:4,10,1;_checkCase:4,11,1;\ _cancd:4,12,1;_UnixExpert:4,13,1;_backwards:4,14,1;\ _forwards:4,15,1;; SavePanel:T238=s172isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;contentView:/190,224,32;\ delegate:/190,256,32;firstResponder:/190,288,32;\ lastLeftHit:/190,320,32;lastRightHit:/190,352,32;\ counterpart:/190,384,32;fieldEditor:/190,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1168,544,16;wFlags2:/1169,560,16;\ _borderView:/190,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1171,672,32;_invalidCursorView:/190,704,32;\ _miniIcon:/190,736,32;_privat32;\ lastLeftHit:/188,320,32;lastRightHit:/188,352,32;\ counterpart:/188,384,32;fieldEditor:/188,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1145,544,16;wFlags2:/1146,560,16;\ _borderView:/188,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1148=*120,672,32;_invalidCursorView:/188,704,32;\ _miniIcon:/188,736,32;_private:/172,768,32;; __vFlags:T149=s2noClip:4,0,1;translatedDraw:4,1,1;\ drawInSuperview:4,2,1;alreadyFlipped:4,3,1;\ needsFlipped:4,4,1;rotatedFromBase:4,5,1;\ rotatedOrScaledFromBase:4,6,1;opaque:4,7,1;\ disableAutodisplay:4,8,1;needsDisplay:4,9,1;\ validGState:4,10,1;newGState:4,11,1;_RESERVED:4,12,2;\ _noVerticalAutosizing:4,14,1;_hasDirtySubview:4,15,1;; ___vFlags:T150=s2autosizing:4,0,6;autoresizeSubviews:4,6,1;\ notifyWhenFlipped:4,7,1;ancestorNotifyWasEnabled:4,8,1;\ needsAncestorNotify:4,9,1;notifyToInitGState:4,10,1;\ wantsGState:4,11,1;noCopyOnScroll:4,12,1;\ noDisplayOnScroll:4,13,1;specialClip:4,14,1;\ mark:4,15,1;; View:T151=s80isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;; _bFlags:T152=s2borderType:4,0,2;titlePosition:4,2,3;\ _transparent:4,5,1;_RESERVED:4,6,10;; Box:T153=s130isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;cell:/188,640,32;\ contentView:/188,672,32;offsets:/155,704,64;borderRect:/1133,768,128;\ titleRect:/1133,896,128;bFlags:/1152,1024,16;; _conFlags:T154=s2enabled:4,0,1;editingValid:4,1,1;\ ignoreMultiClick:4,2,1;calcSize:4,3,1;_drawingAncestor:4,4,1;\ _RESERVED:4,5,11;; Control:T155=s92isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;tag:/11,640,32;\ cell:/188,672,32;conFlags:/1154,704,16;_reservedCshort1:/19,720,16;; Button:T156=s92isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;tag:/11,640,32;\ cell:/188,672,32;conFlags:/1154,704,16;_reservedCshort1:/19,720,16;; Panel:T157=s100isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;contentView:/188,224,32;\ delegate:/188,256,32;firstResponder:/188,288,32;\ lastLeftHit:/188,320,32;lastRightHit:/188,352,32;\ counterpart:/188,384,32;fieldEditor:/188,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1145,544,16;wFlags2:/1146,560,16;\ _borderView:/188,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1148,672,32;_invalidCursorView:/188,704,32;\ _miniIcon:/188,736,32;_private:/172,768,32;; ChoosePrinter:T158=s156isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;contentView:/188,224,32;\ delegate:/188,256,32;firstResponder:/188,288,32;\ lastLeftHit:/188,320,32;lastRightHit:/188,352,32;\ counterpart:/188,384,32;fieldEditor:/188,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1145,544,16;wFlags2:/1146,560,16;\ _borderView:/188,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1148,672,32;_invalidCursorView:/188,704,32;\ _miniIcon:/188,736,32;_private:/172,768,32;appIcon:/188,800,32;\ ok:/188,832,32;cancel:/188,864,32;border:/188,896,32;\ exitTag:/11,928,32;name:/188,960,32;type:/188,992,32;\ note:/188,1024,32;_lastValues:/1159=*93,1056,32;accessoryView:/188,1088,32;\ _reservedChoosePrinter1:/14,1120,32;_reservedChoosePrinter2:/14,1152,32;\ _reservedChoosePrinter3:/14,1184,32;_reservedChoosePrinter4:/14,1216,32;; __clFlags:T160=s2isGraySet:4,0,1;_RESERVED:4,1,11;\ _onlyUncovered:4,12,1;_reflectScroll:4,13,1;\ _usedByCell:4,14,1;_scrollClipTo:4,15,1;; ClipView:T161=s114isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;backgroundGray:/112,640,32;\ docView:/188,672,32;_docRect:/1133,704,128;cursor:/188,832,32;\ _private:/172,864,32;_clFlags:/1160,896,16;; NXCharMetrics:Tt162=s32charCode:8,0,16;numKernPairs:11,16,8;\ reserved:11,24,8;xWidth:12,32,32;name:1,64,32;\ bbox:163=ar1;0;3;12,96,128;kernPairIndex:1,224,32;; NXLigature:Tt164=s12firstCharIndex:1,0,32;secondCharIndex:1,32,32;\ ligatureIndex:1,64,32;; NXEncodedLigature:Tt165=s4firstChar:11,0,8;secondChar:11,8,8;\ ligatureChar:11,16,8;reserved:11,24,8;; NXKernPair:Tt166=s12secondCharIndex:1,0,32;dx:12,32,32;\ dy:12,64,32;; NXKernXPair:Tt167=s8secondCharIndex:1,0,32;dx:12,32,32;; NXTrackKern:Tt168=s20degree:1,0,32;minPointSize:12,32,32;\ minKernAmount:12,64,32;maxPointSize:12,96,32;\ maxKernAmount:12,128,32;; NXCompositeChar:Tt169=s12compCharIndex:1,0,32;numParts:1,32,32;\ firstPartIndex:1,64,32;; NXCompositeCharPart:Tt170=s12partIndex:1,0,32;dx:12,32,32;\ dy:12,64,32;; _NXFontMetrics:T171=s164formatVersion:20,0,32;name:20,32,32;\ fullName:20,64,32;familyName:20,96,32;weight:20,128,32;\ italicAngle:12,160,32;isFixedPitch:2,192,8;isScreenFont:2,200,8;\ screenFontSize:8,208,16;fontBBox:163,224,128;underlinePosition:12,352,32;\ underlineThickness:12,384,32;version:20,416,32;\ notice:20,448,32;encodingScheme:20,480,32;capHeight:12,512,32;\ xHeight:12,544,32;ascender:12,576,32;descender:12,608,32;\ hasYWidths:8,640,16;widths:172=*12,656,32;widthsLength:4,688,32;\ strings:20,720,32;stringsLength:4,752,32;hasXYKerns:2,784,8;\ reserved:2,792,8;encoding:173=*8,800,32;yWidths:172,832,32;\ charMetrics:174=*162,864,32;numCharMetrics:1,896,32;\ ligatures:175=*164,928,32;numLigatures:1,960,32;\ encLigatures:176=*165,992,32;numEncLigatures:1,1024,32;\ kerns:177=u4kernPairs:178=*166,0,32;kernXPairs:179=*167,0,32;;,1056,32;\ numKernPairs:1,1088,32;trackKerns:180=*168,1120,32;\ numTrackKerns:1,1152,32;compositeChars:181=*169,1184,32;\ numCompositeChars:1,1216,32;compositeCharParts:182=*170,1248,32;\ numCompositeCharParts:1,1280,32;; NXFontMetrics:Tt171 NXFontTraitMask:t4 _fmFlags:T183=s2multipleFont:4,0,1;disabled:4,1,1;\ _RESERVED:4,2,14;; FontManager:T184=s48isa:/185,0,32;panel:/188,32,32;\ menu:/188,64,32;action:/189,96,32;whatToDo:/11,128,32;\ traitToChange:/14,160,32;selFont:/188,192,32;fmFlags:/1183,224,16;\ _lastPos:/19,240,16;delegate:/188,256,32;_reservedFMint2:/14,288,32;\ _reservedFMint3:/14,320,32;_reservedFMint4:/14,352,32;; _fpFlags:T185=s2multipleFont:4,0,1;dirty:4,1,1;\ _RESERVED:4,2,11;_amPreviewing:4,13,1;_alwaysPreview:4,14,1;\ _dontPreview:4,15,1;; FontPanel:T186=s184isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;contentView:/188,224,32;\ delegate:/188,256,32;firstResponder:/188,288,32;\ lastLeftHit:/188,320,32;lastRightHit:/188,352,32;\ counterpart:/188,384,32;fieldEditor:/188,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1145,544,16;wFlags2:/1146,560,16;\ _borderView:/188,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1148,672,32;_invalidCursorView:/188,704,32;\ _miniIcon:/188,736,32;_private:/172,768,32;faces:/188,800,32;\ families:/188,832,32;preview:/188,8e:/172,768,32;form:/190,800,32;\ browser:/190,832,32;okButton:/190,864,32;accessoryView:/190,896,32;\ separator:/190,928,32;filename:/120,960,32;directory:/120,992,32;\ filenames:/1186,1024,32;requiredType:/120,1056,32;\ _columns:/172,1088,32;_typeTable:/1171,1120,32;spFlags:/1237,1152,16;\ directorySize:/19,1168,16;_cdcolumn:/11,1184,32;\ _filterMethod:/193,1216,32;_homeButton:/190,1248,32;\ _scroller:/190,1280,32;_fncmp:/193,1312,32;_removableDeviceButton:/190,1344,32;; PageLayout:T239=s176isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;contentView:/190,224,32;\ delegate:/190,256,32;firstResponder:/190,288,32;\ lastLeftHit:/190,320,32;lastRightHit:/190,352,32;\ counterpart:/190,384,32;fieldEditor:/190,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1168,544,16;wFlags2:/1169,560,16;\ _borderView:/190,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1171,672,32;_invalidCursorView:/190,704,32;\ _miniIcon:/190,736,32;_private:/172,768,32;appIcon:/190,800,32;\ height:/190,832,32;width:/190,864,32;ok:/190,896,32;\ cancel:/190,928,32;orientation:/190,960,32;scale:/190,992,32;\ paperSizeList:/190,1024,32;layoutList:/190,1056,32;\ unitsList:/190,1088,32;exitTag:/11,1120,32;paperView:/190,1152,32;\ _paperViewShadow:/190,1184,32;accessoryView:/190,1216,32;\ _currUnits:/12,1248,8;_otherPaper:/12,1256,8;\ _reservedPageLayout1:/19,1264,16;_reservedPageLayout2:/14,1280,32;\ _reservedPageLayout3:/14,1312,32;_reservedPageLayout4:/14,1344,32;\ _reservedPageLayout5:/14,1376,32;; PopUpList:T240=s126isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;contentView:/190,224,32;\ delegate:/190,256,32;firstResponder:/190,288,32;\ lastLeftHit:/190,320,32;lastRightHit:/190,352,32;\ counterpart:/190,384,32;fieldEditor:/190,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1168,544,16;wFlags2:/1169,560,16;\ _borderView:/190,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1171,672,32;_invalidCursorView:/190,704,32;\ _miniIcon:/190,736,32;_private:/172,768,32;supermenu:/190,800,32;\ matrix:/190,832,32;attachedMenu:/190,864,32;lastLocation:/154,896,64;\ reserved:/190,960,32;menuFlags:/1215,992,16;; NXPrivatePrintInfo:t241=*242=xs_PrivatePrintInfo: _pInfoFlags:T243=s2orientation:4,0,1;horizCentered:4,1,1;\ vertCentered:4,2,1;_RESERVEDA:4,3,2;manualFeed:4,5,1;\ allPages:4,6,1;_RESERVEDC:4,7,1;horizPagination:4,8,2;\ vertPagination:4,10,2;printerIsOld:4,12,1;\ reversePageOrder:4,13,1;_RESERVEDB:4,14,2;; PrintInfo:T244=s112isa:/187,0,32;paperType:/120,32,32;\ paperRect:/1137,64,128;leftPageMargin:/112,192,32;\ rightPageMargin:/112,224,32;topPageMargin:/112,256,32;\ bottomPageMargin:/112,288,32;scalingFactor:/112,320,32;\ pageOrder:/12,352,8;pInfoFlags:/1243,368,16;firstPage:/11,384,32;\ lastPage:/11,416,32;currentPage:/11,448,32;copies:/11,480,32;\ outputFile:/120,512,32;context:/140,544,32;_privateData:/1241,576,32;\ printerName:/120,608,32;printerType:/120,640,32;\ printerHost:/120,672,32;resolution:/11,704,32;\ pagesPerSheet:/18,736,16;_reservedPrintInfo1:/19,752,16;\ printerObject:/1245=*235,768,32;jobFeaturesTable:/190,800,32;\ paperFeed:/195,832,32;_reservedPrintInfo5:/14,864,32;; PrintPanel:T246=s188isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;contentView:/190,224,32;\ delegate:/190,256,32;firstResponder:/190,288,32;\ lastLeftHit:/190,320,32;lastRightHit:/190,352,32;\ counterpart:/190,384,32;fieldEditor:/190,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1168,544,16;wFlags2:/1169,560,16;\ _borderView:/190,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1171,672,32;_invalidCursorView:/190,704,32;\ _miniIcon:/190,736,32;_private:/172,768,32;appIcon:/190,800,32;\ pageMode:/190,832,32;firstPage:/190,864,32;lastPage:/190,896,32;\ copies:/190,928,32;ok:/190,960,32;cancel:/190,992,32;\ preview:/190,1024,32;save:/190,1056,32;printers:/190,1088,32;\ feed:/190,1120,32;resolutionList:/190,1152,32;name:/190,1184,32;\ note:/190,1216,32;status:/190,1248,32;exitTag:/11,1280,32;\ accessoryView:/190,1312,32;_ppdTextView:/190,1344,32;\ buttons:/190,1376,32;_ppdGroupView:/190,1408,32;optionsButton:/190,1440,32;\ _priv:/172,1472,32;; SelectionCell:T247=s20isa:/187,0,32;contents:/120,32,32;\ support:/190,64,32;cFlags1:/1138,96,16;cFlags2:/1139,112,16;\ _cFlags3:/1140,128,16;_reservedCshort:/19,144,16;; SliderCell:T248=s88isa:/187,0,32;contents:/120,32,32;\ support:/190,64,32;cFlags1:/1138,96,16;cFlags2:/1139,112,16;\ _cFlags3:/1140,128,16;_reservedCshort:/19,144,16;\ tag:/11,160,32;target:/190,192,32;action:/191,224,32;\ _view:/190,256,32;_scPrivate:/172,288,32;_scPrivate1:/11,320,32;\ _scPrivate2:/11,352,32;value:/113,384,64;maxValue:/113,448,64;\ minValue:/113,512,64;trackRect:/1137,576,128;; Speaker:T249=s32isa:/187,0,32;sendPort:/11,32,32;\ replyPort:/11,64,32;sendTimeout:/11,96,32;replyTimeout:/11,128,32;\ delegate:/190,160,32;_reservedSpeaker1:/11,192,32;\ _reservedSpeaker2:/11,224,32;; TextFieldCell:T250=s48isa:/187,0,32;contents:/120,32,32;\ support:/190,64,32;cFlags1:/1138,96,16;cFlags2:/1139,112,16;\ _cFlags3:/1140,128,16;_reservedCshort:/19,144,16;\ tag:/11,160,32;target:/190,192,32;action:/191,224,32;\ _view:/190,256,32;backgroundGray:/112,288,32;textGray:/112,320,32;\ _private:/172,352,32;; _NXSoundParameterTag:T251=eNX_SoundDeviceBufferSize:0,NX_SoundDeviceBufferCount:1,\ NX_SoundDeviceDetectPeaks:2,NX_SoundDeviceRampUp:3,\ NX_SoundDeviceRampDown:4,NX_SoundDeviceInsertZeros:5,\ NX_SoundDeviceDeemphasize:6,NX_SoundDeviceMuteSpeaker:7,\ NX_SoundDeviceMuteHeadphone:8,NX_SoundDeviceMuteLineOut:9,\ NX_SoundDeviceOutputLoudness:10,NX_SoundDeviceOutputAttenuationStereo:11,\ NX_SoundDeviceOutputAttenuationLeft:12,NX_SoundDeviceOutputAttenuationRight:13,\ NX_SoundDeviceAnalogInputSource:14,NX_SoundDeviceMonitorAttenuation:15,\ NX_SoundDeviceInputGainStereo:16,NX_SoundDeviceInputGainLeft:17,\ NX_SoundDeviceInputGainRight:18,NX_SoundDeviceAnalogInputSource_Microphone:200,\ NX_SoundDeviceAnalogInputSource_LineIn:201,NX_SoundStreamDataEncoding:400,\ NX_SoundStreamSamplingRate:401,NX_SoundStreamChannelCount:402,\ NX_SoundStreamHighWaterMark:403,NX_SoundStreamLowWaterMark:404,\ NX_SoundStreamSource:405,NX_SoundStreamSink:406,NX_SoundStreamDetectPeaks:407,\ NX_SoundStreamGainStereo:408,NX_SoundStreamGainLeft:409,\ NX_SoundStreamGainRight:410,NX_SoundStreamDataEncoding_Linear16:600,\ NX_SoundStreamDataEncoding_Linear8:601,NX_SoundStreamDataEncoding_Mulaw8:602,\ NX_SoundStreamDataEncoding_Alaw8:603,NX_SoundStreamDataEncoding_AES:604,\ NX_SoundStreamSource_Analog:605,NX_SoundStreamSource_AES:606,\ NX_SoundStreamSink_Analog:607,NX_SoundStreamSink_AES:608,; NXSoundParameterTag:t251 NXSoundParameters:T252=s16isa:/187,0,32;_paramTable:/1253=*125,32,32;\ _paramList:/1254=*251,64,32;_reserved:/11,96,32;; _NXSoundDeviceError:T255=eNX_SoundDeviceErrorNone:0,NX_SoundDeviceErrorKernel:300,\ NX_SoundDeviceErrorTimeout:301,NX_SoundDeviceErrorLookUp:302,\ NX_SoundDeviceErrorHost:303,NX_SoundDeviceErrorNoDevice:304,\ NX_SoundDeviceErrorNotActive:305,NX_SoundDeviceErrorTag:306,\ NX_SoundDeviceErrorParameter:307,NX_SoundDeviceErrorMax:399,; NXSoundDeviceError:t255 NXSoundDevice:T256=s44isa:/187,0,32;_host:/195,32,32;\ _devicePort:/11,64,32;_streamOwnerPort:/11,96,32;\ _bufferSize:/14,128,32;_bufferCount:/14,160,32;\ _isDetectingPeaks:/14,192,32;_peakHistory:/14,224,32;\ _kernelError:/11,256,32;_lastError:/1255,288,32;\ _reserved:/11,320,32;; NXSoundStream:T257=s34isa:/187,0,32;delegate:/190,32,32;\ _isActive:/12,64,8;_isPaused:/12,72,8;_device:/190,80,32;\ _streamPort:/11,112,32;_delegateMessages:/14,144,32;\ _kernelError:/11,176,32;_lastError:/1255,208,32;\ _reserved:/11,240,32;; worldpatch_t:Tt258=s26originx:1,0,32;originy:1,32,32;\ patchname:259=ar1;0;8;2,64,72;stepdir:1,144,32;\ colormap:1,176,32;; worldtexture_t:Tt260=s2626WADindex:1,0,32;name:259,32,72;\ dirty:2,104,8;width:1,112,32;height:1,144,32;\ patchcount:1,17664,32;current:/188,896,32;\ size:/188,928,32;sizes:/188,960,32;manager:/188,992,32;\ selFont:/188,1024,32;selMetrics:/1187=*171,1056,32;\ curTag:/11,1088,32;accessoryView:/188,1120,32;_keyBuffer:/120,1152,32;\ setButton:/188,1184,32;separator:/188,1216,32;sizeTitle:/188,1248,32;\ lastPreview:/120,1280,32;fpFlags:/1185,1312,16;_reservedFPshort1:/19,1328,16;\ _lastKeyTime:/13,1344,32;_chooser:/188,1376,32;_titles:/188,1408,32;\ _previewBox:/188,1440,32;; _mFlags:T188=s2highlightMode:4,0,1;radioMode:4,1,1;\ listMode:4,2,1;allowEmptySel:4,3,1;autoscroll:4,4,1;\ reaction:4,5,1;selectionByRect:4,6,1;_RESERVED:4,7,7;\ _autosizeCells:4,14,1;_drawingAncestor:4,15,1;; Matrix:T189=s192isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;tag:/11,640,32;\ cell:/188,672,32;conFlags:/1154,704,16;_reservedCshort1:/19,720,16;\ cellList:/188,736,32;target:/188,768,32;action:/189,800,32;\ selectedCell:/188,832,32;selectedRow:/11,864,32;\ selectedCol:/11,896,32;numRows:/11,928,32;numCols:/11,960,32;\ cellSize:/155,992,64;intercell:/155,1056,64;backgroundGray:/112,1120,32;\ cellBackgroundGray:/112,1152,32;font:/188,1184,32;\ protoCell:/188,1216,32;cellClass:/188,1248,32;nextText:/188,1280,32;\ previousText:/188,1312,32;doubleAction:/189,1344,32;\ errorAction:/189,1376,32;textDelegate:/188,1408,32;\ mFlags:/1188,1440,16;_reservedMshort1:/19,1456,16;\ _reservedMint1:/14,1472,32;_private:/172,1504,32;; Form:T190=s192isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;tag:/11,640,32;\ cell:/188,672,32;conFlags:/1154,704,16;_reservedCshort1:/19,720,16;\ cellList:/188,736,32;target:/188,768,32;action:/189,800,32;\ selectedCell:/188,832,32;selectedRow:/11,864,32;\ selectedCol:/11,896,32;numRows:/11,928,32;numCols:/11,960,32;\ cellSize:/155,992,64;intercell:/155,1056,64;backgroundGray:/112,1120,32;\ cellBackgroundGray:/112,1152,32;font:/188,1184,32;\ protoCell:/188,1216,32;cellClass:/188,1248,32;nextText:/188,1280,32;\ previousText:/188,1312,32;doubleAction:/189,1344,32;\ errorAction:/189,1376,32;textDelegate:/188,1408,32;\ mFlags:/1188,1440,16;_reservedMshort1:/19,1456,16;\ _reservedMint1:/14,1472,32;_private:/172,1504,32;; _menuFlags:T191=s2sizeFitted:4,0,1;autoupdate:4,1,1;\ attached:4,2,1;tornOff:4,3,1;wasAttached:4,4,1;\ wasTornOff:4,5,1;_RESERVED:4,6,6;_templateType:4,12,2;\ _isServicesMenu:4,14,1;_changeTitle:4,15,1;; Menu:T192=s126isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;contentView:/188,224,32;\ delegate:/188,256,32;firstResponder:/188,288,32;\ lastLeftHit:/188,320,32;lastRightHit:/188,352,32;\ counterpart:/188,384,32;fieldEditor:/188,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1145,544,16;wFlags2:/1146,560,16;\ _borderView:/188,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1148,672,32;_invalidCursorView:/188,704,32;\ _miniIcon:/188,736,32;_private:/172,768,32;supermenu:/188,800,32;\ matrix:/188,832,32;attachedMenu:/188,864,32;lastLocation:/154,896,64;\ reserved:/188,960,32;menuFlags:/1191,992,16;; NXBrowser:T193=s156isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;tag:/11,640,32;\ cell:/188,672,32;conFlags:/1154,704,16;_reservedCshort1:/19,720,16;\ target:/188,736,32;delegate:/188,768,32;_reserved1:/1194=ar1;0;2;88,800,96;\ action:/189,896,32;doubleAction:/189,928,32;matrixClass:/188,960,32;\ cellPrototype:/188,992,32;_reserved2:/155,1024,64;\ _reserved4:/164,1088,64;pathSeparator:/19,1152,16;\ _reserved3:/1195=ar1;0;5;2,1168,48;_private:/172,1216,32;; NXColorPanel:T196=s164isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;contentView:/188,224,32;\ delegate:/188,256,32;firstResponder:/188,288,32;\ lastLeftHit:/188,320,32;lastRightHit:/188,352,32;\ counterpart:/188,384,32;fieldEditor:/188,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1145,544,16;wFlags2:/1146,560,16;\ _borderView:/188,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1148,672,32;_invalidCursorView:/188,704,32;\ _miniIcon:/188,736,32;_private:/172,768,32;_cpPrivate:/172,800,32;\ _reservedCPint:/1197=ar1;0;14;1,832,480;; NXColorWell:T198=s124isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;tag:/11,640,32;\ cell:/188,672,32;conFlags:/1154,704,16;_reservedCshort1:/19,720,16;\ color:/1131,736,128;_target:/188,864,32;_action:/189,896,32;\ _isActive:/12,928,8;_isBordered:/12,936,8;_cantDraw:/12,944,8;\ _isNotContinuous:/12,952,8;_reservedPtr:/172,960,32;; NXDataLinkPanel:T199=s152isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;contentView:/188,224,32;\ delegate:/188,256,32;firstResponder:/188,288,32;\ lastLeftHit:/188,320,32;lastRightHit:/188,352,32;\ counterpart:/188,384,32;fieldEditor:/188,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1145,544,16;wFlags2:/1146,560,16;\ _borderView:/188,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1148,672,32;_invalidCursorView:/188,704,32;\ _miniIcon:/188,736,32;_private:/172,768,32;breakLink:/088,800,32;\ openSource:/088,832,32;updateDestination:/088,864,32;\ updateMode:/088,896,32;breakAllLinks:/088,928,32;\ showOutlines:/088,960,32;bannerMsg:/088,992,32;\ sourceTitle:/088,1024,32;sourceValue:/088,1056,32;\ lastUpdateTitle:/088,1088,32;lastUpdateValue:/088,1120,32;\ accessoryView:/088,1152,32;needsUpdate:/02,1184,8;\ reserved1:/02,1192,8;reserved2:/08,1200,16;; NXHelpPanel:T200=s104isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;contentView:/188,224,32;\ delegate:/188,256,32;firstResponder:/188,288,32;\ lastLeftHit:/188,320,32;lastRightHit:/188,352,32;\ counterpart:/188,384,32;fieldEditor:/188,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1145,544,16;wFlags2:/1146,560,16;\ _borderView:/188,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1148,672,32;_invalidCursorView:/188,704,32;\ _miniIcon:/188,736,32;_private:/172,768,32;private:/172,800,32;; _objc_protocol:T201=s20isa:202=*203=xs_objc_class:,0,32;\ protocol_name:20,32,32;protocol_list:204=*205=*201,64,32;\ instance_methods:206=*207=xs_objc__method_prototype_list:,96,32;\ class_methods:206,128,32;; NXSplitView:T208=s84isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;delegate:/188,640,32;; _spFlags:T209=s2opening:4,0,1;exitOk:4,1,1;\ allowMultiple:4,2,1;dirty:4,3,1;invalidateMatrices:4,4,1;\ filtered:4,5,1;_chooseFolders:4,6,1;_ignoreFilePackages:4,7,1;\ _largeFS:4,8,1;_delegateValidatesNew:4,9,1;\ _delegateValidatesOld:4,10,1;_checkCase:4,11,1;\ _cancd:4,12,1;_UnixExpert:4,13,1;_backwards:4,14,1;\ _forwards:4,15,1;; Sav,32;patches:261=ar1;0;99;258,208,20800;; sectordef_t:Tt262=s38floorheight:1,0,32;ceilingheight:1,32,32;\ floorflat:259,64,72;ceilingflat:259,136,72;lightlevel:1,208,32;\ special:1,240,32;tag:1,272,32;; DoomProject:T263=s3026isa:/187,0,32;loaded:/12,32,8;\ projectdirectory:/1264=ar1;0;1023;2,40,8192;wadfile:/1264,8232,8192;\ nummaps:/11,16432,32;mapnames:/1265=ar1;0;99;259,16464,7200;\ texturessize:/11,23664,32;window_i:/190,23696,32;projectpath_i:/190,23728,32;\ wadpath_i:/190,23760,32;maps_i:/190,23792,32;thingPanel_i:/190,23824,32;\ findPanel_i:/190,23856,32;mapNameField_i:/190,23888,32;\ BSPprogram_i:/190,23920,32;BSPhost_i:/190,23952,32;\ mapwaddir_i:/190,23984,32;projectdirty:/12,24016,8;\ texturesdirty:/12,24024,8;mapdirty:/12,24032,8;\ thermoTitle_i:/190,24048,32;thermoMsg_i:/190,24080,32;\ thermoView_i:/190,24112,32;thermoWindow_i:/190,24144,32;\ printPrefWindow_i:/190,24176,32;; worldpoint_t:Tt266=s16selected:1,0,32;refcount:1,32,32;\ pt:54,64,64;; worldside_t:Tt267=s78flags:1,0,32;firstcollumn:1,32,32;\ toptexture:259,64,72;bottomtexture:259,136,72;midtexture:259,208,72;\ ends:262,288,304;sector:1,592,32;; worldline_t:Tt268=s196selected:1,0,32;p1:1,32,32;\ p2:1,64,32;special:1,96,32;tag:1,128,32;\ flags:1,160,32;side:269=ar1;0;1;267,192,1248;\ mid:54,1440,64;norm:54,1504,64;; worldthing_t:Tt270=s28selected:1,0,32;origin:54,32,64;\ angle:1,96,32;type:1,128,32;options:1,160,32;\ area:1,192,32;; worldsector_t:Tt271=s42s:262,0,304;lines:90,304,32;; copyline_t:Tt272=s212l:268,0,1568;p1:54,1568,64;\ p2:54,1632,64;; EditWorld:T273=s1110isa:/187,0,32;loaded:/12,32,8;\ pointssize:/11,48,32;linessize:/11,80,32;thingssize:/11,112,32;\ texturessize:/11,144,32;dirty:/12,176,8;dirtypoints:/12,184,8;\ bounds:/1137,192,128;boundsdirty:/12,320,8;pathname:/1264,328,8192;\ dirtyrect:/1137,8528,128;windowlist_i:/190,8656,32;\ copyThings_i:/190,8688,32;copyLines_i:/190,8720,32;\ copyCoord:/154,8752,64;copyLoaded:/11,8816,32;saveSound:/190,8848,32;; byte:t11  :T274=efalse:0,true:1,; boolean:t274 box_t:Tt275=s16left:12,0,32;bottom:12,32,32;\ right:12,64,32;top:12,96,32;; flat_t:Tt276=s34image:90,0,32;name:259,32,72;\ r:137,112,128;WADindex:1,240,32;; SectorEditor:T277=s130isa:/187,0,32;window_i:/190,32,32;\ sectorEditView_i:/190,64,32;flatScrPalView_i:/190,96,32;\ flatPalView_i:/190,128,32;lightLevel_i:/190,160,32;\ lightSlider_i:/190,192,32;special_i:/190,224,32;\ tag_i:/190,256,32;floorAndCeiling_i:/190,288,32;\ ceiling_i:/190,320,32;floor_i:/190,352,32;cheightfield_i:/190,384,32;\ fheightfield_i:/190,416,32;cflatname_i:/190,448,32;\ fflatname_i:/190,480,32;totalHeight_i:/190,512,32;\ curFlat_i:/190,544,32;ceiling_flat:/11,576,32;\ floor_flat:/11,608,32;sector:/1262,640,304;flatImages:/190,944,32;\ currentFlat:/11,976,32;specialPanel_i:/190,1008,32;; type_t:Tt278=s80orgname:279=ar1;0;39;2,0,320;newname:279,320,320;; Remapper:T280=s72isa:/187,0,32;original_i:/190,32,32;\ new_i:/190,64,32;remapPanel_i:/190,96,32;remapString_i:/190,128,32;\ status_i:/190,160,32;browser_i:/190,192,32;matrix_i:/190,224,32;\ storage_i:/190,256,32;delegate_i:/190,288,32;frameName:/1281=ar1;0;31;2,320,256;; FlatRemapper:T282=s8isa:/187,0,32;remapper_i:/190,32,32;; _objc_super:T283=s8self:90,0,32;class:148,32,32;; _objc_class:T149=s40isa:148,0,32;super_class:148,32,32;\ name:20,64,32;version:3,96,32;info:3,128,32;\ instance_size:3,160,32;ivars:284=*285=xs_objc_ivar_list:,192,32;\ methods:286=*287=xs_objc_method_list:,224,32;cache:100,256,32;\ protocol_list:150,288,32;; -[FlatRemapper init] -[FlatRemapper init]:f90 self:p288=*282 _cmd:p91 self:r288   -[FlatRemapper menuTarget:] -[FlatRemapper menuTarget:]:f90 self:p288 _cmd:p91 sender:p90 self:r288   -[FlatRemapper addToList:to:] -[FlatRemapper addToList:to:]:f90 self:p288 _cmd:p91 orgname:p20 newname:p20 self:r288   -[FlatRemapper getOriginalName] -[FlatRemapper getOriginalName]:f20 self:p288 _cmd:p91   -[FlatRemapper getNewName] -[FlatRemapper getNewName]:f20 self:p288 _cmd:p91   -[FlatRemapper doRemap:to:] -[FlatRemapper doRemap:to:]:f1 self:p288 _cmd:p91 oldname:p20 newname:p20 oldname:r20 newname:r20 i:r1 linenum:r1 flag:r1   -[FlatRemapper finishUp] -[FlatRemapper finishUp]:f90 self:p288 _cmd:p91   _objc_category:T289=s20category_name:20,0,32;class_name:20,32,32;\ instance_methods:286,64,32;class_methods:286,96,32;\ protocol_list:150,128,32;; _objc_symtab:T290=s16sel_ref_cnt:3,0,32;refs:291=*91,32,32;\ cls_def_cnt:8,64,16;cat_def_cnt:8,80,16;defs:292=ar1;0;0;72,96,32;; _objc_ivar:T293=s12ivar_name:20,0,32;ivar_type:20,32,32;\ ivar_offset:1,64,32;; _OBJC_INSTANCE_VARIABLES_FlatRemapper:S294=s16ivar_count:1,0,32;\ ivar_list:295=ar1;0;0;293,32,96;; _objc_method:T296=s12_cmd:91,0,32;method_types:20,32,32;\ _imp:72,64,32;; _OBJC_INSTANCE_METHODS_FlatRemapper:S297=s92method_next:152,0,32;\ method_count:1,32,32;method_list:298=ar1;0;6;296,64,672;; _OBJC_CLASS_PROTOCOLS_FlatRemapper:S299=ar1;0;2;151 _OBJC_METACLASS_FlatRemapper:S149 _OBJC_CLASS_FlatRemapper:S149 _OBJC_SELECTOR_REFERENCES_0:S91 _OBJC_SELECTOR_REFERENCES_1:S91 _OBJC_SELECTOR_REFERENCES_2:S91 _OBJC_SELECTOR_REFERENCES_3:S91 _OBJC_SELECTOR_REFERENCES_4:S91 _OBJC_SELECTOR_REFERENCES_5:S91 _objc_method_prototype:T300=s8_cmd:91,0,32;method_types:20,32,32;; _OBJC_PROTOCOL_INSTANCE_METHODS_Remapper:S301=s36method_count:1,0,32;\ method_list:302=ar1;0;3;300,32,256;; _OBJC_PROTOCOL_Remapper:S147 _objc_module:T303=s16version:3,0,32;size:3,32,32;\ name:20,64,32;symtab:304=*290,96,32;; _OBJC_CLASS_REFERENCES_0:S87 _OBJC_CLASS_NAME_0:S305=ar1;0;12;2 _OBJC_CLASS_NAME_1:S306=ar1;0;6;2 _OBJC_CLASS_NAME_2:S307=ar1;0;8;2 _OBJC_CLASS_NAME_3:S308=ar1;0;14;2 _OBJC_METH_VAR_NAME_0:S309=ar1;0;10;2 _OBJC_METH_VAR_NAME_1:S310=ar1;0;8;2 _OBJC_METH_VAR_NAME_2:S311=ar1;0;11;2 _OBJC_METH_VAR_NAME_3:S312=ar1;0;10;2 _OBJC_METH_VAR_NAME_4:S313=ar1;0;15;2 _OBJC_METH_VAR_NAME_5:S314=ar1;0;13;2 _OBJC_METH_VAR_NAME_6:S315=ar1;0;11;2 _OBJC_METH_VAR_NAME_7:S316=ar1;0;4;2 _OBJC_METH_VAR_NAME_8:S317=ar1;0;5;2 _OBJC_METH_VAR_NAME_9:S318=ar1;0;70;2 _OBJC_METH_VAR_NAME_10:S319=ar1;0;9;2 _OBJC_METH_VAR_NAME_11:S320=ar1;0;14;2 _OBJC_METH_VAR_NAME_12:S321=ar1;0;9;2 _OBJC_METH_VAR_TYPE_0:S322=ar1;0;1;2 _OBJC_METH_VAR_TYPE_1:S323=ar1;0;7;2 _OBJC_METH_VAR_TYPE_2:S324=ar1;0;14;2 _OBJC_METH_VAR_TYPE_3:S325=ar1;0;7;2 _OBJC_METH_VAR_TYPE_4:S326=ar1;0;14;2 _OBJC_METH_VAR_TYPE_5:S327=ar1;0;11;2 flatRemapper_i:G90                                              <    <               __text          __TEXT              v       
  .               __cstring       __TEXT          v  V   2                         __class         __OBJC            (        h                 __meta_class    __OBJC            (                         __cat_cls_meth  __OBJC                                     __cat_inst_meth __OBJC          (  $                         __cls_meth      __OBJC          L      	                          __inst_meth     __OBJC          L  \   	                       __message_refs  __OBJC               d	                     __symbols       __OBJC               |	                      __category      __OBJC                	                          __protocol      __OBJC               	                      __class_vars    __OBJC                	                          __instance_vars __OBJC               	                      __module_info   __OBJC               	                       __string_object __OBJC                	                          __class_names   __OBJC            ,   	                         __meth_var_names__OBJC          0     	                         __meth_var_types__OBJC            <   
                         __cls_refs      __OBJC          8     
                               8    US]    Shv  h{  h  h    R  R8  RPC]]US]  RSR]]US]URUR  RSRm]]U  R    RNP  R    R:]U  R    RP  R    R
]UWVSE    1U9    B  1[4        DPURuUR    DP   [4ePanel:T210=s172isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;contentView:/188,224,32;\ delegate:/188,256,32;firstResponder:/188,288,32;\ lastLeftHit:/188,320,32;lastRightHit:/188,352,32;\ counterpart:/188,384,32;fieldEditor:/188,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1145,544,16;wFlags2:/1146,560,16;\ _borderView:/188,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1148,672,32;_invalidCursorView:/188,704,32;\ _miniIcon:/188,736,32;_private:/172,768,32;form:/188,800,32;\ browser:/188,832,32;okButton:/188,864,32;accessoryView:/188,896,32;\ separator:/188,928,32;filename:/120,960,32;directory:/120,992,32;\ filenames:/1159,1024,32;requiredType:/120,1056,32;\ _columns:/172,1088,32;_typeTable:/1148,1120,32;spFlags:/1209,1152,16;\ directorySize:/19,1168,16;_cdcolumn:/11,1184,32;\ _filterMethod:/191,1216,32;_homeButton:/188,1248,32;\ _scroller:/188,1280,32;_fncmp:/191,1312,32;_removableDeviceButton:/188,1344,32;; PageLayout:T211=s176isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;contentView:/188,224,32;\ delegate:/188,256,32;firstResponder:/188,288,32;\ lastLeftHit:/188,320,32;lastRightHit:/188,352,32;\ counterpart:/188,384,32;fieldEditor:/188,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1145,544,16;wFlags2:/1146,560,16;\ _borderView:/188,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1148,672,32;_invalidCursorView:/188,704,32;\ _miniIcon:/188,736,32;_private:/172,768,32;appIcon:/188,800,32;\ height:/188,832,32;width:/188,864,32;ok:/188,896,32;\ cancel:/188,928,32;orientation:/188,960,32;scale:/188,992,32;\ paperSizeList:/188,1024,32;layoutList:/188,1056,32;\ unitsList:/188,1088,32;exitTag:/11,1120,32;paperView:/188,1152,32;\ _paperViewShadow:/188,1184,32;accessoryView:/188,1216,32;\ _currUnits:/12,1248,8;_otherPaper:/12,1256,8;\ _reservedPageLayout1:/19,1264,16;_reservedPageLayout2:/14,1280,32;\ _reservedPageLayout3:/14,1312,32;_reservedPageLayout4:/14,1344,32;\ _reservedPageLayout5:/14,1376,32;; PopUpList:T212=s126isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;contentView:/188,224,32;\ delegate:/188,256,32;firstResponder:/188,288,32;\ lastLeftHit:/188,320,32;lastRightHit:/188,352,32;\ counterpart:/188,384,32;fieldEditor:/188,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1145,544,16;wFlags2:/1146,560,16;\ _borderView:/188,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1148,672,32;_invalidCursorView:/188,704,32;\ _miniIcon:/188,736,32;_private:/172,768,32;supermenu:/188,800,32;\ matrix:/188,832,32;attachedMenu:/188,864,32;lastLocation:/154,896,64;\ reserved:/188,960,32;menuFlags:/1191,992,16;; PrintPanel:T213=s188isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;contentView:/188,224,32;\ delegate:/188,256,32;firstResponder:/188,288,32;\ lastLeftHit:/188,320,32;lastRightHit:/188,352,32;\ counterpart:/188,384,32;fieldEditor:/188,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1145,544,16;wFlags2:/1146,560,16;\ _borderView:/188,576,32;_displayDisabled:/18,608,16;\ _flushDisabled:/18,624,16;_cursorRects:/172,640,32;\ _trectTable:/1148,672,32;_invalidCursorView:/188,704,32;\ _miniIcon:/188,736,32;_private:/172,768,32;appIcon:/188,800,32;\ pageMode:/188,832,32;firstPage:/188,864,32;lastPage:/188,896,32;\ copies:/188,928,32;ok:/188,960,32;cancel:/188,992,32;\ preview:/188,1024,32;save:/188,1056,32;printers:/188,1088,32;\ feed:/188,1120,32;resolutionList:/188,1152,32;name:/188,1184,32;\ note:/188,1216,32;status:/188,1248,32;exitTag:/11,1280,32;\ accessoryView:/188,1312,32;_ppdTextView:/188,1344,32;\ buttons:/188,1376,32;_ppdGroupView:/188,1408,32;optionsButton:/188,1440,32;\ _priv:/172,1472,32;; __sFlags:T214=s2vScrollerRequired:4,0,1;hScrollerRequired:4,1,1;\ vScrollerStatus:4,2,1;hScrollerStatus:4,3,1;\ noDynamicScrolling:4,4,1;borderType:4,5,2;\ rulerInstalled:4,7,1;_RESERVED:4,8,8;; ScrollView:T215=s106isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;vScroller:/188,640,32;\ hScroller:/188,672,32;contentView:/188,704,32;pageContext:/112,736,32;\ lineAmount:/112,768,32;_sFlags:/1214,800,16;_ruler:/188,816,32;; _sFlags:T216=s2isHoriz:4,0,1;arrowsLoc:4,1,2;\ partsUsable:4,3,2;_fine:4,5,1;_RESERVED:4,6,6;\ _needsEnableFlush:4,12,1;_thumbing:4,13,1;\ _slotDrawn:4,14,1;_knobDrawn:4,15,1;; Scroller:T217=s118isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;tag:/11,640,32;\ cell:/188,672,32;conFlags:/1154,704,16;_reservedCshort1:/19,720,16;\ curValue:/112,736,32;perCent:/112,768,32;_knobSize:/112,800,32;\ hitPart:/11,832,32;target:/188,864,32;action:/189,896,32;\ sFlags:/1216,928,16;; Slider:T218=s92isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;tag:/11,640,32;\ cell:/188,672,32;conFlags:/1154,704,16;_reservedCshort1:/19,720,16;; _NXChunk:T219=s10growby:8,0,16;allocated:1,16,32;\ used:1,48,32;; NXChunk:Tt219 wchar:t11 _tbFlags:T220=s2malloced:4,0,1;PAD:4,1,15;; _NXTextBlock:T221=s16next:222=*221,0,32;prior:222,32,32;\ tbFlags:220,64,16;chars:8,80,16;text:223=*11,96,32;; NXTextBlock:Tt221 NXRunFlags:Tt224=s2underline:4,0,1;dummy:4,1,1;\ subclassWantsRTF:4,2,1;graphic:4,3,1;forcedSymbol:4,4,1;\ RESERVED:4,5,11;; _NXRun:T225=s28font:88,0,32;chars:1,32,32;\ paraStyle:72,64,32;textGray:12,96,32;textRGBColor:1,128,32;\ superscript:11,160,8;subscript:11,168,8;info:88,176,32;\ rFlags:224,208,16;; NXRun:Tt225 _NXRunArray:T226=s38chunk:219,0,80;runs:227=ar1;0;0;225,80,224;; NXRunArray:Tt226 NXLineDesc:t8 _NXBreakArray:T228=s12chunk:219,0,80;breaks:229=ar1;0;0;8,80,16;; NXBreakArray:Tt228 NXLayFlags:Tt230=s2mustMove:4,0,1;isMoveChar:4,1,1;\ RESERVED:4,2,14;; _NXLay:T231=s26x:12,0,32;y:12,32,32;\ offset:8,64,16;chars:8,80,16;font:88,96,32;\ paraStyle:72,128,32;run:232=*225,160,32;lFlags:230,192,16;; NXLay:Tt231 _NXLayArray:T233=s36chunk:219,0,80;lays:234=ar1;0;0;231,80,208;; NXLayArray:Tt233 _NXWidthArray:T235=s14chunk:219,0,80;widths:236=ar1;0;0;12,80,32;; NXWidthArray:Tt235 _NXCharArray:T237=s12chunk:219,0,80;text:238=ar1;0;0;11,80,8;; NXCharArray:Tt237 _NXFSM:T239=s8next:240=*239,0,32;delta:8,32,16;\ token:8,48,16;; NXFSM:Tt239 _NXSelPt:T241=s24cp:1,0,32;line:1,32,32;\ x:12,64,32;y:12,96,32;c1st:1,128,32;\ ht:12,160,32;; NXSelPt:Tt241 _NXTextCache:T242=s20curPos:1,0,32;curRun:232,32,32;\ runFirstPos:1,64,32;curBlock:243=*221,96,32;blockFirstPos:1,128,32;; NXTextCache:Tt242 _lFlags:T244=s2horizCanGrow:4,0,1;vertCanGrow:4,1,1;\ erase:4,2,1;ping:4,3,1;endsParagraph:4,4,1;\ resetCache:4,5,1;RESERVED:4,6,10;; _NXLayInfo:T245=s74rect:133,0,128;descent:12,128,32;\ width:12,160,32;left:12,192,32;right:12,224,32;\ rightIndent:12,256,32;lays:246=*233,288,32;widths:247=*235,320,32;\ chars:248=*237,352,32;cache:242,384,160;textClipRect:249=*133,544,32;\ lFlags:244,576,16;; NXLayInfo:Tt245 NXTextFunc:t250=*251=f1 NXCharFilterFunc:t252=*253=f9 NXTextFilterFunc:t254=*255=f20 _tFlags:T256=s2_editMode:4,0,2;_selectMode:4,2,2;\ _caretState:4,4,2;changeState:4,6,1;charWrap:4,7,1;\ haveDown:4,8,1;anchorIs0:4,9,1;horizResizable:4,10,1;\ vertResizable:4,11,1;overstrikeDiacriticals:4,12,1;\         MPURvuUR    MPZG[4           PUR2uUR       PG[4           PURuUR       PGtURURh  EC9    Ee[^_]UE]Flat List of flats to be remapped Flat Remapper FlatRemapper Remapped flat %s to %s.
                   L                     (                             ;    D    P    [           ;    l  D       P       [       k    t   y  *  T                 k                            (         0             !    FlatRemapper Object Remapper FlatRemapper.m remapper_i finishUp doRemap:to: getNewName getOriginalName addToList:to: menuTarget: init alloc setFrameName:setPanelTitle:setBrowserTitle:setRemapString:setDelegate: showPanel getCurrentFlat flatName: @ @8@8:12 i16@8:12*16*20 *8@8:12 @16@8:12*16*20 @12@8:12@16     U   H   C    .   #                              y   \   S   @   3                 	             	             	             	         	  g    ]   	  A    8    2     +   	  $   	                      	    $                               $                                                                   X     T     P     L     H     D     @     <     8     4     0     ,     (     $                                                                                                    
                d                                   .         G         e                                    -         J         f         x                                                      *         6   %     E         o                              T              7   Y     K         |                              d              2   m     E         w   t        t                              8        M        c                                    T                                                    9                                    	         W	       g	       x	        	         	        	         	        	          
         R
         ~
         
         
                  S                                   "         P         p        |           _                        D                       9         g                                   $         [            }                	              	                1        A        I         ~                           >         p   2                                %   ?     E                                             ;         i                                    )        Q            *                               D         [                                    .         E                                    I         f                                    "         b         y                                      !              6         f                                             7         j                                    4         e                                    K         ~                                             O                                    .         |   h                                =         X                                    '         i                           /    R     e                              !         N!         !         !         !         !         <"         "         "         "         :#         j#         #         #         :$         $         $         $         /%         `%         %         %          &         4&         j&         &         &         '         8'         p'         '         '         '         <(         }(         (         (         )         1)         k)         })         )         )         **         ]*         *         *         +         :+         o+         +         +          ,         T,         ,         ,         ,         -         1-         a-         -         -         -         +.         ?.         u.         .         .         2/         e/         /         /         0          0         Z0         0         0         1         J1         1         1         2         F2         2         2         2         63         {3         3         3          4         @4         w4         4         4         5         C5         S5         5         5         5         66         i6         6         6         7         U7         7         7         8         48         f8         8         8         9         F9         9         9         9         /:         a:         :         :         :         ;;         q;         ;         ;         !<         X<         <         <         '=         q=         =         =   0     >         W>   8     o>         >   A     >         ?   H     ?   O     V?         ?         ?   X     ?         @   `     4@         p@   g     ~@         @         @         7A         A         A         A         .B         nB         B         B         !C         SC         C         C         
D         DD         D         D        D   	     D         E         E         KE         E         E         F         EF         vF         F         F         G         HG         zG         G         G         H         TH         H         H         H         8I         wI         I         I         .J         uJ         J         
K         %K         ZK         K         K         L         CL         zL         L         L         M         RM         rM         M         M         N         AN         xN         N         N         O         QO         O         O         O         1P         kP         P         P         $Q         YQ         Q         Q         R         ?R         R         R         R         S         IS         |S         S         S         T         DT         sT         T         T         U         ZU         U         U         V         3V         bV         V         V         W         MW         W         W         W         X         @X         X         X         Y         5Y         hY         Y         Y         Z         EZ         zZ         Z         Z         .[         a[         [         [         \         7\         d\         \         \         ]         I]         {]         ]         ]         &^         [^         ^         ^         _         N_        _         _   0      `         :`         h`         `         `         a         @a         |a         a         a         +b         Fb         ub         b         b         /c         wc         c         c         d         Ud         d         d         d         d         7e         ye         e         e         f         ?f         f         f         f         *g         hg         g         g         %h         lh         h         h         %i         bi         i         monoFont:4,13,1;disableFontPanel:4,14,1;inClipView:4,15,1;; Text:T257=s358isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;breakTable:/1240,640,32;\ clickTable:/1240,672,32;preSelSmartTable:/1258=*11,704,32;\ postSelSmartTable:/1258,736,32;charCategoryTable:/1258,768,32;\ delegateMethods:/12,800,8;charFilterFunc:/1252,816,32;\ textFilterFunc:/1254,848,32;_compilerErrorSpacer:/120,880,32;\ scanFunc:/1250,912,32;drawFunc:/1250,944,32;delegate:/188,976,32;\ tag:/11,1008,32;cursorTE:/183,1040,32;firstTextBlock:/1243,1072,32;\ lastTextBlock:/1243,1104,32;theRuns:/1259=*226,1136,32;\ typingRun:/1225,1168,224;theBreaks:/1260=*228,1392,32;\ growLine:/11,1424,32;textLength:/11,1456,32;maxY:/112,1488,32;\ maxX:/112,1520,32;bodyRect:/1133,1552,128;borderWidth:/112,1680,32;\ clickCount:/12,1712,8;sp0:/1241,1728,192;spN:/1241,1920,192;\ anchorL:/1241,2112,192;anchorR:/1241,2304,192;backgroundGray:/112,2496,32;\ textGray:/112,2528,32;selectionGray:/112,2560,32;\ maxSize:/155,2592,64;minSize:/155,2656,64;tFlags:/1256,2720,16;\ _info:/172,2736,32;textStream:/1261=*68,2768,32;_reservedText1:/14,2800,32;\ _reservedText2:/14,2832,32;; TextField:T262=s112isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;tag:/11,640,32;\ cell:/188,672,32;conFlags:/1154,704,16;_reservedCshort1:/19,720,16;\ nextText:/188,736,32;previousText:/188,768,32;textDelegate:/188,800,32;\ errorAction:/189,832,32;_reservedTFint1:/14,864,32;; SoundView:T263=s134isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;sound:/188,640,32;\ _private:/188,672,32;delegate:/188,704,32;selectionRect:/1133,736,128;\ displayMode:/11,864,32;backgroundGray:/112,896,32;\ foregroundGray:/112,928,32;reductionFactor:/112,960,32;\ svFlags:/1264=s2disabled:4,0,1;continuous:4,1,1;\ calcDrawInfo:4,2,1;selectionDirty:4,3,1;\ autoscale:4,4,1;bezeled:4,5,1;notEditable:4,6,1;\ notOptimizedForSpeed:4,7,1;_reservedFlags:4,8,8;;,992,16;\ _scratchSound:/188,1008,32;_currentSample:/11,1040,32;; SoundMeter:T265=s142isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;sound:/188,640,32;\ currentSample:/11,672,32;currentValue:/112,704,32;\ currentPeak:/112,736,32;minValue:/112,768,32;maxValue:/112,800,32;\ holdTime:/112,832,32;backgroundGray:/112,864,32;\ foregroundGray:/112,896,32;peakGray:/112,928,32;\ smFlags:/1266=s2running:4,0,1;bezeled:4,1,1;\ shouldStop:4,2,1;_reservedFlags:4,3,13;;,960,16;\ _timedEntry:/183,976,32;_valTime:/11,1008,32;_peakTime:/11,1040,32;\ _valOneAgo:/112,1072,32;_valTwoAgo:/112,1104,32;; worldpatch_t:Tt267=s26originx:1,0,32;originy:1,32,32;\ patchname:268=ar1;0;8;2,64,72;stepdir:1,144,32;\ colormap:1,176,32;; worldtexture_t:Tt269=s2626WADindex:1,0,32;name:268,32,72;\ dirty:2,104,8;width:1,112,32;height:1,144,32;\ patchcount:1,176,32;patches:270=ar1;0;99;267,208,20800;; sectordef_t:Tt271=s38floorheight:1,0,32;ceilingheight:1,32,32;\ floorflat:268,64,72;ceilingflat:268,136,72;lightlevel:1,208,32;\ special:1,240,32;tag:1,272,32;; DoomProject:T272=s3026isa:/185,0,32;loaded:/12,32,8;\ projectdirectory:/1273=ar1;0;1023;2,40,8192;wadfile:/1273,8232,8192;\ nummaps:/11,16432,32;mapnames:/1274=ar1;0;99;268,16464,7200;\ texturessize:/11,23664,32;window_i:/188,23696,32;projectpath_i:/188,23728,32;\ wadpath_i:/188,23760,32;maps_i:/188,23792,32;thingPanel_i:/188,23824,32;\ findPanel_i:/188,23856,32;mapNameField_i:/188,23888,32;\ BSPprogram_i:/188,23920,32;BSPhost_i:/188,23952,32;\ mapwaddir_i:/188,23984,32;projectdirty:/12,24016,8;\ texturesdirty:/12,24024,8;mapdirty:/12,24032,8;\ thermoTitle_i:/188,24048,32;thermoMsg_i:/188,24080,32;\ thermoView_i:/188,24112,32;thermoWindow_i:/188,24144,32;\ printPrefWindow_i:/188,24176,32;; byte:t11  :T275=efalse:0,true:1,; boolean:t275 box_t:Tt276=s16left:12,0,32;bottom:12,32,32;\ right:12,64,32;top:12,96,32;; flat_t:Tt277=s34image:88,0,32;name:268,32,72;\ r:133,112,128;WADindex:1,240,32;; SectorEditor:T278=s130isa:/185,0,32;window_i:/188,32,32;\ sectorEditView_i:/188,64,32;flatScrPalView_i:/188,96,32;\ flatPalView_i:/188,128,32;lightLevel_i:/188,160,32;\ lightSlider_i:/188,192,32;special_i:/188,224,32;\ tag_i:/188,256,32;floorAndCeiling_i:/188,288,32;\ ceiling_i:/188,320,32;floor_i:/188,352,32;cheightfield_i:/188,384,32;\ fheightfield_i:/188,416,32;cflatname_i:/188,448,32;\ fflatname_i:/188,480,32;totalHeight_i:/188,512,32;\ curFlat_i:/188,544,32;ceiling_flat:/11,576,32;\ floor_flat:/11,608,32;sector:/1271,640,304;flatImages:/188,944,32;\ currentFlat:/11,976,32;specialPanel_i:/188,1008,32;; divider_t:Tt279=s40x:1,0,32;y:1,32,32;\ string:280=ar1;0;31;2,64,256;; FlatsView:T281=s84isa:/185,0,32;nextResponder:/188,32,32;\ _reserved:/188,64,32;frame:/1133,96,128;bounds:/1133,224,128;\ superview:/188,352,32;subviews:/188,384,32;window:/188,416,32;\ vFlags:/1149,448,16;_vFlags:/1150,464,16;_gState:/11,480,32;\ _frameMatrix:/188,512,32;_drawMatrix:/188,544,32;\ _dragTypes:/1136,576,32;_vPrivate:/172,608,32;dividers_i:/188,640,32;; _objc_super:T282=s8self:88,0,32;class:202,32,32;; _objc_class:T203=s40isa:202,0,32;super_class:202,32,32;\ name:20,64,32;version:3,96,32;info:3,128,32;\ instance_size:3,160,32;ivars:283=*284=xs_objc_ivar_list:,192,32;\ methods:285=*286=xs_objc_method_list:,224,32;cache:98,256,32;\ protocol_list:204,288,32;; -[FlatsView initFrame:] -[FlatsView initFrame:]:f88 self:p287=*281 _cmd:p89 frameRect:p288=*133 self:r287 frameRect:r288 _objc_super:282   -[FlatsView addDividerX:Y:String:] -[FlatsView addDividerX:Y:String:]:f88 self:p287 _cmd:p89 x:p1 y:p1 string:p20 self:r287 d:279   -[FlatsView dumpDividers] -[FlatsView dumpDividers]:f88 self:p287 _cmd:p89 self:r287   -[FlatsView drawSelf::] -[FlatsView drawSelf::]:f88 self:p287 _cmd:p89 rects:p288 rectCount:p1 self:r287 rects:r288 f:r289=*277 max:r1 i:r1 cf:r1 r:133 d:r290=*279   -[FlatsView mouseDown:] -[FlatsView mouseDown:]:f88 self:p287 _cmd:p89 theEvent:p291=*66 self:r287 theEvent:r291 loc:54 i:r1 max:r1 oldwindowmask:r1   _objc_category:T292=s20category_name:20,0,32;class_name:20,32,32;\ instance_methods:285,64,32;class_methods:285,96,32;\ protocol_list:204,128,32;; _objc_symtab:T293=s16sel_ref_cnt:3,0,32;refs:294=*89,32,32;\ cls_def_cnt:8,64,16;cat_def_cnt:8,80,16;defs:295=ar1;0;0;72,96,32;; _objc_ivar:T296=s12ivar_name:20,0,32;ivar_type:20,32,32;\ ivar_offset:1,64,32;; _OBJC_INSTANCE_VARIABLES_FlatsView:S297=s16ivar_count:1,0,32;\ ivar_list:298=ar1;0;0;296,32,96;; _objc_method:T299=s12_cmd:89,0,32;method_types:20,32,32;\ _imp:72,64,32;; _OBJC_INSTANCE_METHODS_FlatsView:S300=s68method_next:206,0,32;\ method_count:1,32,32;method_list:301=ar1;0;4;299,64,480;; _OBJC_METACLASS_FlatsView:S203 _OBJC_CLASS_FlatsView:S203 _OBJC_SELECTOR_REFERENCES_0:S89 _OBJC_SELECTOR_REFERENCES_1:S89 _OBJC_SELECTOR_REFERENCES_2:S89 _OBJC_SELECTOR_REFERENCES_3:S89 _OBJC_SELECTOR_REFERENCES_4:S89 _OBJC_SELECTOR_REFERENCES_5:S89 _OBJC_SELECTOR_REFERENCES_6:S89 _OBJC_SELECTOR_REFERENCES_7:S89 _OBJC_SELECTOR_REFERENCES_8:S89 _OBJC_SELECTOR_REFERENCES_9:S89 _OBJC_SELECTOR_REFERENCES_10:S89 _OBJC_SELECTOR_REFERENCES_11:S89 _OBJC_SELECTOR_REFERENCES_12:S89 _OBJC_SELECTOR_REFERENCES_13:S89 _OBJC_SELECTOR_REFERENCES_14:S89 _OBJC_SELECTOR_REFERENCES_15:S89 _i         	j         ;j         jj         j         j         k         Uk         k         k         l         Al         l         l         l         3m         wm         m         m         n         Jn         }n         n         n         $o         Zo         o         o         p         Sp         p        p         p         q         Dq         yq         q         q         q         %r         ]r         r         r         s         _s         s         s         s         :t         qt         t         t         "u         Uu         u         u         u         2v         gv         v         v         $w         \w         w         w         x         Px         x         x         x         *y         ]y         y         y         z         <z         ~z         z         z          {         d{         {         {         {         /|         b|         |         |         |         H}         }}         }         }         *~         u~         ~                  Q                           .         o                           ?                                    R   ;     k                           8         w                           1        I                                             M         d                                    A         X                                            >        w                     #              N                           !         k                                    ?         w                                            S                                            H   %     i                     3        9              G   ?     W                                    Q                                            $        1         _        }                                   B         w                           "         W                                    4        w                           5                                    ,         Z                                     D       D      D      D H     D J     $     %       4       =  @     G       H    J   I    T   e  D  T   e  D! [   e  D" k   e  D# m   e  $  T                             @          [       m       t     D& t     D' {     D(      D)      $& t      %       %       %       %      @ %    $    {   %       &       F  D1    F  D2    F  D3    F  $1    j   1    t   1    }       ~                D6      D7      D8      $6       6       6                           D;      D<     D@     DA     DC      DE "    DG K    DH `    DI e    DJ h    DL     DM     DN     DQ     DS     DT     DU     DV     DX     DY 2    DZ 3    D\ 6    D^ :    D_ L    D` O    DA R    Dd _    De b    $;    	   ;       ;       ;    (   ;    4  @ <    9   = C  @ >    K      L    b  M    l  f  Dh l  f  Di r  f  Dj r  f  $h l     h       h      @ h         r      r                             5         r                             &    H  &m   j                    &  L    &m L  1  &m   e  &m     &m     &	m     &	m     &	m     &	m   %  &	m   E  &	m   e           &  (    &m (    &m   1         d           &m 8    &m     &m     &m     &m !  1  &m 0  W  &m ;  |  &m D    &m P    &m [    &m k    &m y  :  &m   _  &m     &m     &m     &m     &m     &m   B  &m   g  &m     &m     &m     &m *             d  v            t                    Z                   7          -                    R                    >          J           _flatRemapper_i _objc_msgSend _sectorEdit_i _numlines _lines _strcasecmp _strcpy _printf .objc_class_name_Remapper .objc_class_name_Object .objc_class_name_Protocol .objc_class_name_FlatRemapper FlatRemapper.m int:t1=r1;-2147483648;2147483647; char:t2=r2;0;127; long int:t3=r1;-2147483648;2147483647; unsigned int:t4=r1;0;-1; long unsigned int:t5=r1;0;-1; long long int:t6=r1;01000000000000000000000;0777777777777777777777; long long unsigned int:t7=r1;0000000000000;01777777777777777777777; short int:t8=r1;-32768;32767; short unsigned int:t9=r1;0;65535; signed char:t10=r1;-128;127; unsigned char:t11=r1;0;255; float:t12=r1;4;0; double:t13=r1;8;0; long double:t14=r1;12;0; complex int:t15=s8real:1,0,32;imag:1,32,32;; complex float:t16=r16;4;0; complex double:t17=r17;8;0; complex long double:t18=r18;12;0; void:t19=19 va_list:t20=*2 _iobuf:T21=s20_cnt:1,0,32;_ptr:20,32,32;\ _base:20,64,32;_bufsiz:1,96,32;_flag:8,128,16;\ _file:11,144,8;_smallbuf:2,152,8;;  :T22=edps_ascii:0,dps_binObjSeq:1,dps_encodedTokens:2,; DPSProgramEncoding:t22  :T23=edps_indexed:0,dps_strings:1,; DPSNameEncoding:t23  :T24=edps_tBoolean:0,dps_tChar:1,dps_tUChar:2,\ dps_tFloat:3,dps_tDouble:4,dps_tShort:5,\ dps_tUShort:6,dps_tInt:7,dps_tUInt:8,\ dps_tLong:9,dps_tULong:10,; DPSDefinedType:t24  :T25=edps_machServer:0,dps_fdServer:1,dps_stream:2,; DPSContextType:t25 DPSResultsRec:t26=s12type:24,0,32;count:1,32,32;\ value:20,64,32;; DPSResults:t27=*26 DPSSpaceRec:t28=s8lastNameIndex:1,0,32;procs:29=*30=xs_t_DPSSpaceProcsRec:,32,32;; DPSSpace:t31=*28 _t_DPSSpaceProcsRec:T30=s4DestroySpace:32=*33=f19,0,32;; DPSSpaceProcsRec:t30 DPSSpaceProcs:t34=*30 _t_DPSContextRec:T35=s48priv:20,0,32;space:31,32,32;\ programEncoding:22,64,32;nameEncoding:23,96,32;\ procs:36=*37=xs_t_DPSProcsRec:,128,32;textProc:38=*39=f19,160,32;\ errorProc:38,192,32;resultTable:27,224,32;resultTableLength:4,256,32;\ chainParent:40=*35,288,32;chainChild:40,320,32;\ type:25,352,32;; DPSContextRec:t35 DPSContext:t40 _t_DPSProcsRec:T37=s56BinObjSeqWrite:41=*42=f19,0,32;\ WriteTypedObjectArray:43=*44=f19,32,32;WriteStringChars:45=*46=f19,64,32;\ WriteData:41,96,32;WritePostScript:41,128,32;FlushContext:47=*48=f19,160,32;\ ResetContext:47,192,32;UpdateNameMap:47,224,32;\ AwaitReturnValues:47,256,32;Interrupt:47,288,32;\ DestroyContext:47,320,32;WaitContext:47,352,32;\ Printf:49=*50=f19,384,32;WriteNumString:51=*52=f19,416,32;; DPSProcsRec:t37 DPSProcs:t53=*37 NXCoord:t12 _NXPoint:T54=s8x:12,0,32;y:12,32,32;; NXPoint:t54 _NXSize:T55=s8width:12,0,32;height:12,32,32;; NXSize:t55 NXEventData:t56=u12mouse:57=s12reserved:8,0,16;\ eventNum:8,16,16;click:1,32,32;pressure:11,64,8;\ reserved1:2,72,8;reserved2:8,80,16;;,0,96;\ key:58=s12reserved:8,0,16;repeat:8,16,16;\ charSet:9,32,16;charCode:9,48,16;keyCode:9,64,16;\ keyData:8,80,16;;,0,96;tracking:59=s12reserved:8,0,16;\ eventNum:8,16,16;trackingNum:1,32,32;userData:1,64,32;;,0,96;\ compound:60=s12reserved:8,0,16;subtype:8,16,16;\ misc:61=u8F:62=ar1;0;1;12,0,64;L:63=ar1;0;1;3,0,64;\ S:64=ar1;0;3;8,0,64;C:65=ar1;0;7;2,0,64;;,32,64;;,0,96;; _NXEvent:T66=s40type:1,0,32;location:54,32,64;\ time:3,96,32;flags:1,128,32;window:4,160,32;\ data:56,192,96;ctxt:40,288,32;; NXEvent:t66 NXEventPtr:t67=*66 integer_t:t1 port_name_t:t1 port_t:t1 kern_return_t:t1 _NXStream:T68=s40magic_number:4,0,32;buf_base:69=*11,32,32;\ buf_ptr:69,64,32;buf_size:1,96,32;buf_left:1,128,32;\ offset:3,160,32;flags:1,192,32;eof:1,224,32;\ functions:70=*71=xsstream_functions:,256,32;info:72=*19,288,32;; NXStream:t68 stream_functions:T71=s28read_bytes:73=*74=f1,0,32;\ write_bytes:75=*76=f1,32,32;flush_buffer:77=*78=f1,64,32;\ fill_buffer:77,96,32;change_buffer:79=*80=f19,128,32;\ seek:81=*82=f19,160,32;destroy:79,192,32;; DPSEventFilterFunc:t83objc_module:T302=s16version:3,0,32;size:3,32,32;\ name:20,64,32;symtab:303=*293,96,32;; _OBJC_CLASS_REFERENCES_0:S85 _OBJC_CLASS_NAME_0:S304=ar1;0;9;2 _OBJC_CLASS_NAME_1:S305=ar1;0;4;2 _OBJC_CLASS_NAME_2:S306=ar1;0;6;2 _OBJC_CLASS_NAME_3:S307=ar1;0;11;2 _OBJC_CLASS_NAME_4:S308=ar1;0;7;2 _OBJC_METH_VAR_NAME_0:S309=ar1;0;10;2 _OBJC_METH_VAR_NAME_1:S310=ar1;0;10;2 _OBJC_METH_VAR_NAME_2:S311=ar1;0;10;2 _OBJC_METH_VAR_NAME_3:S312=ar1;0;12;2 _OBJC_METH_VAR_NAME_4:S313=ar1;0;21;2 _OBJC_METH_VAR_NAME_5:S314=ar1;0;10;2 _OBJC_METH_VAR_NAME_6:S315=ar1;0;5;2 _OBJC_METH_VAR_NAME_7:S316=ar1;0;34;2 _OBJC_METH_VAR_NAME_8:S317=ar1;0;11;2 _OBJC_METH_VAR_NAME_9:S318=ar1;0;5;2 _OBJC_METH_VAR_NAME_10:S319=ar1;0;14;2 _OBJC_METH_VAR_NAME_11:S320=ar1;0;8;2 _OBJC_METH_VAR_NAME_12:S321=ar1;0;11;2 _OBJC_METH_VAR_NAME_13:S322=ar1;0;18;2 _OBJC_METH_VAR_NAME_14:S323=ar1;0;5;2 _OBJC_METH_VAR_NAME_15:S324=ar1;0;10;2 _OBJC_METH_VAR_NAME_16:S325=ar1;0;15;2 _OBJC_METH_VAR_NAME_17:S326=ar1;0;22;2 _OBJC_METH_VAR_NAME_18:S327=ar1;0;11;2 _OBJC_METH_VAR_NAME_19:S328=ar1;0;15;2 _OBJC_METH_VAR_NAME_20:S329=ar1;0;13;2 _OBJC_METH_VAR_TYPE_0:S330=ar1;0;1;2 _OBJC_METH_VAR_TYPE_1:S331=ar1;0;98;2 _OBJC_METH_VAR_TYPE_2:S332=ar1;0;30;2 _OBJC_METH_VAR_TYPE_3:S333=ar1;0;7;2 _OBJC_METH_VAR_TYPE_4:S334=ar1;0;17;2 _OBJC_METH_VAR_TYPE_5:S335=ar1;0;27;2                                                                 __text          __TEXT                        D               __cstring       __TEXT               	                         __literal4      __TEXT               	                        __class         __OBJC            (   	     (                 __meta_class    __OBJC             (    
     P                 __cat_cls_meth  __OBJC          H      H
                          __cat_inst_meth __OBJC          H      H
                          __cls_meth      __OBJC          H      H
                          __inst_meth     __OBJC          H  D   H
     h                 __message_refs  __OBJC            @   
                     __symbols       __OBJC               
     `                 __category      __OBJC                
                          __protocol      __OBJC                
                          __class_vars    __OBJC                
                          __instance_vars __OBJC               
     h                 __module_info   __OBJC               
     x                 __string_object __OBJC                
                          __class_names   __OBJC            *   
                         __meth_var_names__OBJC          &  #  &                         __meth_var_types__OBJC          I     I                         __cls_refs      __OBJC                                              ,>    UVS]uj j(j   R  R  RPCTV  R]  UEPe[^]U(VSuUUUUUR]EPuS  RVTRde[^]US]  RSTRA]]UWVS  Q    R|bP  Q    RKMSUKM[]  E]m]  E]E]EP  R    QE19}EW  R    QsVURqtVj  QSXG9}h  @Ah  @j 9  RMITQ&E19  W  RMITQ j C$$CPh  ? j j h  CCP$$$CP$$UB$%  $nCP$$$N$CP$$MA$%  $!G9}Ee[^_]UWVS}j@  RMI4QEWOUMj EP  QUR  Q    R1$9}YS  Q    RPEP{<u,u
S  S  Q    RPC9|MQ  RMI4Q,Ee[^_]Helvetica-Bold   @   A              X     H                       (                          1  K     <       G       T    d   j        u  {  j                        +  ;                  &  I  T             FlatsView View Object FlatsView.m Storage dividers_i mouseDown: drawSelf:: dumpDividers addDividerX:Y:String: initFrame: alloc initCount:elementSize:description: addElement: empty getCurrentFlat getFlat: getNumFlats composite:toPoint: count elementAt: addToEventMask: convertPoint:fromView: selectFlat: setCurrentFlat: setEventMask: @ @12@8:12^{?=i{?=ff}liI({?=ssiCcs}{?=ssSSSs}{?=ssii}{?=ss([2f][2l][4s][8c])})^{_t_DPSContextRec}}16 @16@8:12^{?={?=ff}{?=ff}}16i20 @8@8:12 @20@8:12i16i20*24 @12@8:12^{?={?=ff}{?=ff}}16         
          
    
     t   n   g  
  U   O   H  
  B   8  
       
                      d   D   3   )   $              
       
                 
     |   v   o  
  \   V   O  
  F   /                   
             
         
         
      S    G    =   
  3    *    $        
     
     	                                       @     <     8     4     0     ,     (     $                                         <     8     4     0     ,     (     $                                                                                     d      '         I         [                                             A         _                                                               %         @         \         ~            %                                         O   T     f            Y                                !         =   d     P            m                 t        t             B        S                                                    a                                                    B                           	         >	         o	         	       	       	        	         	        

         8
        C
         t
         
         
         
         0         h                                   F         v                                     _                     	         F         |                                   ,         g                             	              .        9        V        f        n                                    a            2                                H   ?     h                                    %         ^                                             K        s            *                      &         f         }                                    f                                    ,         l                                                !              H         _                                    ?         r                           #         _                                    $         j                                    S                           %         Y                                    A         x                                    >                                             R                                    &          Q          }                              !         &!         _!         !         !         "         8"         g"         "         "         #         W#         #         #         #         +$         X$         $         $         $         
%         9%         f%         %         %         %         &         ]&         &         &         '         >'  =*84=f1 DPSTimedEntry:t85=*86=xs__DPSTimedEntry: Class:t87=*88=xsobjc_class: objc_object:T89=s4isa:87,0,32;; id:t90=*89 SEL:t91=*92=xsobjc_selector: IMP:t93=*94=f90 BOOL:t2 objc_class:T88=s40isa:87,0,32;super_class:87,32,32;\ name:95=*2,64,32;version:3,96,32;info:3,128,32;\ instance_size:3,160,32;ivars:96=*97=xsobjc_ivar_list:,192,32;\ methods:98=*99=xsobjc_method_list:,224,32;cache:100=*101=xsobjc_cache:,256,32;\ protocols:102=*103=xsobjc_protocol_list:,288,32;; Ivar:t104=*105=xsobjc_ivar: objc_ivar:T105=s12ivar_name:20,0,32;ivar_type:20,32,32;\ ivar_offset:1,64,32;; objc_ivar_list:T97=s16ivar_count:1,0,32;ivar_list:106=ar1;0;0;105,32,96;; Method:t107=*108=xsobjc_method: objc_method:T108=s12method_name:91,0,32;method_types:20,32,32;\ method_imp:93,64,32;; objc_method_list:T99=s20method_next:98,0,32;method_count:1,32,32;\ method_list:109=ar1;0;0;108,64,96;; objc_protocol_list:T103=s12next:102,0,32;count:1,32,32;\ list:110=ar1;0;0;111=*112=xsProtocol:,64,32;; objc_cache:T101=s12mask:4,0,32;occupied:4,32,32;\ buckets:113=ar1;0;0;107,64,32;; Object:T114=s4isa:/187,0,32;; NXHashTablePrototype:Tt115=s16hash:116=*117=f4,0,32;isEqual:118=*119=f1,32,32;\ free:120=*121=f19,64,32;style:1,96,32;; NXHashTable:Tt122=s20prototype:123=*115,0,32;count:4,32,32;\ nbBuckets:4,64,32;buckets:72,96,32;info:124=*19,128,32;; NXAtom:t95 HashTable:T125=s24isa:/187,0,32;count:/14,32,32;\ keyDesc:/195,64,32;valueDesc:/195,96,32;_nbBuckets:/14,128,32;\ _buckets:/172,160,32;; List:T126=s16isa:/187,0,32;dataPtr:127=*90,32,32;\ numElements:4,64,32;maxElements:4,96,32;; NXStringTable:T128=s24isa:/187,0,32;count:/14,32,32;\ keyDesc:/195,64,32;valueDesc:/195,96,32;_nbBuckets:/14,128,32;\ _buckets:/172,160,32;; objc_method_description:T129=s8name:91,0,32;types:20,32,32;; objc_method_description_list:T130=s12count:1,0,32;list:131=ar1;0;0;129,32,64;; Protocol:T112=s20isa:/187,0,32;protocol_name:/020,32,32;\ protocol_list:/0102,64,32;instance_methods:/0132=*130,96,32;\ class_methods:/0132,128,32;; Storage:T133=s24isa:/187,0,32;dataPtr:72,32,32;\ description:95,64,32;numElements:4,96,32;maxElements:4,128,32;\ elementSize:4,160,32;; StreamTable:T134=s24isa:/187,0,32;count:/14,32,32;\ keyDesc:/195,64,32;valueDesc:/195,96,32;_nbBuckets:/14,128,32;\ _buckets:/172,160,32;; _NXColor:T135=s16colorField:136=ar1;0;5;9,0,96;\ str:95,96,32;; NXColor:Tt135 _NXRect:T137=s16origin:54,0,64;size:55,64,64;; NXRect:Tt137 _cFlags1:T138=s4entryType:4,0,3;scrollable:4,3,1;\ selectable:4,4,1;bezeled:4,5,1;bordered:4,6,1;\ alignment:4,7,2;freeText:4,9,1;type:4,10,2;\ editable:4,12,1;disabled:4,13,1;highlighted:4,14,1;\ state:4,15,1;; _cFlags2:T139=s4dontActOnMouseUp:4,0,1;noWrap:4,1,1;\ _isLoaded:4,2,1;actOnMouseDragged:4,3,1;\ autoRange:4,4,1;floatRight:4,5,4;floatLeft:4,9,4;\ _isLeaf:4,13,1;actOnMouseDown:4,14,1;continuous:4,15,1;; __cFlags3:T140=s4isWhite:4,0,1;useUserKeyEquivalent:4,1,1;\ center:4,2,1;docEditing:4,3,1;docSaved:4,4,1;\ wasSelectable:4,5,1;RESERVED:4,6,10;; Cell:T141=s28isa:/187,0,32;contents:/120,32,32;\ support:/190,64,32;cFlags1:/1138,96,32;cFlags2:/1139,128,32;\ _cFlags3:/1140,160,32;_reservedCshort:/19,192,16;; ActionCell:T142=s44isa:/187,0,32;contents:/120,32,32;\ support:/190,64,32;cFlags1:/1138,96,32;cFlags2:/1139,128,32;\ _cFlags3:/1140,160,32;_reservedCshort:/19,192,16;\ tag:/11,224,32;target:/190,256,32;action:/191,288,32;\ _view:/190,320,32;; Responder:T143=s12isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;; Pasteboard:T144=s56isa:/187,0,32;owner:/190,32,32;\ _realChangeCount:/11,64,32;_ourChangeCount:/11,96,32;\ _server:/11,128,32;_ownerArray:/1127,160,32;_numTypes:/11,192,32;\ _typesArray:/1145=*95,224,32;_client:/11,256,32;\ _typesProvided:/1146=*2,288,32;_name:/195,320,32;\ _host:/195,352,32;_serverVersion:/11,384,32;_reservedPasteboard4:/14,416,32;; time_t:t3 _objc_protocol:T147=s20isa:148=*149=xs_objc_class:,0,32;\ protocol_name:20,32,32;protocol_list:150=*151=*147,64,32;\ instance_methods:152=*153=xs_objc__method_prototype_list:,96,32;\ class_methods:152,128,32;; _lmFlags:T154=s4isEdited:4,0,1;doUI:4,1,1;\ showOutlines:4,2,1;registered:4,3,1;linksDirty:4,4,1;\ delegateVerifiesLinks:4,5,1;RESERVED:4,6,10;; NXDataLinkManager:T155=s48isa:/187,0,32;delegate:/090,32,32;\ ref:/090,64,32;srcLinks:/0156=*126,96,32;destLinks:/0156,128,32;\ lmFlags:/0154,160,32;destLinksCounter:/01,192,32;\ lastEditTime:/03,224,32;linkInfo:/0156,256,32;linkInfoPboard:/0157=*144,288,32;\ linkInfoChangeCount:/01,320,32;_reservedLinkManager1:/04,352,32;; NXLinkEnumerationState:Tt158=s8a:72,0,32;b:72,32,32;; NXLock:T159=s8isa:/187,0,32;_priv:/172,32,32;; NXInvalidationNotifier:T160=s20isa:/187,0,32;refcount:/14,32,32;\ isValid:/12,64,8;listGate:/1161=*159,96,32;funeralList:/1156,128,32;; __appFlags:T162=s4hidden:4,0,1;autoupdate:4,1,1;\ active:4,2,1;_hasBeenRun:4,3,1;_RESERVED:4,4,7;\ _doingUnhide:4,11,1;_delegateReturnsValidRequestor:4,12,1;\ _deactPending:4,13,1;_invalidState:4,14,1;\ _invalidEvent:4,15,1;; Application:T163=s164isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;appName:/120,96,32;currentEvent:/166,128,320;\ windowList:/190,448,32;keyWindow:/190,480,32;mainWindow:/190,512,32;\ delegate:/190,544,32;hiddenList:/1164=*1,576,32;\ hiddenCount:/11,608,32;hostName:/195,640,32;context:/140,672,32;\ contextNum:/11,704,32;appListener:/190,736,32;\ appSpeaker:/190,768,32;replyPort:/11,800,32;screenSize:/155,832,64;\ running:/18,896,16;appFlags:/1162,928,32;_reservedApp4:/190,960,32;\ _focusStack:/190,992,32;_freelist:/190,1024,32;_pboard:/190,1056,32;\ _mainMenu:/190,1088,32;_appIcon:/190,1120,32;_nameTable:/190,1152,32;\ _printInfo:/190,1184,32;_reservedApp1:/14,1216,32;\ _reservedApp2:/14,1248,32;_reservedApp3:/14,1280,32;; __imageFlags:T165=s4unboundedCacheDepth:4,0,1;archiveByName:4,1,1;\ aSynch:4,2,1;subImage:4,3,1;dontFreeName:4,4,1;\ multipleResolutionMatching:4,5,1;colorMatchPreferred:4,6,1;\ useEPSOnResolutionMismatch:4,7,1;needsToExpand:4,8,1;\ builtIn:4,9,1;sizeWasExplicitlySet:4,10,1;\ uniqueWasExplicitlySet:4,11,1;uniqueWindow:4,12,1;\ flipDraw:4,13,1;dataRetained:4,14,1;scalable:4,15,1;; NXImage:T166=s40isa:/187,0,32;name:/120,32,32;\ _size:/155,64,64;_flags:/1165,128,32;_reservedShort:/18,160,16;\ _reps:/172,192,32;_repList:/1156,224,32;_color:/1167=*135,256,32;\ _reservedInt:/11,288,32;; _wFlags:T168=s4oneShot:4,0,1;dontFreeWhenClosed:4,1,1;\ hideOnDeactivate:4,2,1;isPanel:4,3,1;isKeyWindow:4,4,1;\ isMainWindow:4,5,1;visible:4,6,1;buttonMask:4,7,3;\ backing:4,10,2;style:4,12,4;; _wFlags2:T169=s4_floatingPanel:4,0,1;_hiddenOnDeactivate:4,1,1;\ _tempHidden:4,2,1;_windowDying:4,3,1;_repostedFirstMouse:4,4,1;\ _ignoredFirstMouse:4,5,1;_RESERVED:4,6,1;\ _needsFlush:4,7,1;_limitedBecomeKey:4,8,1;\ _worksWhenModal:4,9,1;dynamicDepthLimit:4,10,1;\ docEdited:4,11,1;_validCursorRects:4,12,1;\ _haveFreeCursorRects:4,13,1;_cursorRectsDisabled:4,14,1;\ deferred:4,15,1;; Window:T170=s104isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;contentView:/190,224,32;\ delegate:/190,256,32;firstResponder:/190,288,32;\ lastLeftHit:/190,320,32;lastRightHit:/190,352,32;\ counterpart:/190,384,32;fieldEditor:/190,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1168,544,32;wFlags2:/1169,576,32;\ _borderView:/190,608,32;_displayDisabled:/18,640,16;\ _flushDisabled:/18,656,16;_cursorRects:/172,672,32;\ _trectTable:/1171=*122,704,32;_invalidCursorView:/190,736,32;\ _miniIcon:/190,768,32;_private:/172,800,32;; __vFlags:T172=s4_hasDirtySubview:4,0,1;_noVerticalAutosizing:4,1,1;\ _RESERVED:4,2,2;newGState:4,4,1;validGState:4,5,1;\ needsDisplay:4,6,1;disableAutodisplay:4,7,1;\ opaque:4,8,1;rotatedOrScaledFromBase:4,9,1;\ rotatedFromBase:4,10,1;needsFlipped:4,11,1;\ alreadyFlipped:4,12,1;drawInSuperview:4,13,1;\ translatedDraw:4,14,1;noClip:4,15,1;; ___vFlags:T173=s4mark:4,0,1;specialClip:4,1,1;\ noDisplayOnScroll:4,2,1;noCopyOnScroll:4,3,1;\ wantsGState:4,4,1;notifyToInitGState:4,5,1;\ needsAncestorNotify:4,6,1;ancestorNotifyWasEnabled:4,7,1;\ notifyWhenFlipped:4,8,1;autoresizeSubviews:4,9,1;\ autosizing:4,10,6;; View:T174=s84isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128       t'         '         '         (         R(         (         (         )         K)         z)         )         )         *         ?*         ~*         *         *         /+         n+         +         +         +,         k,         ,         ,         -         `-         -         -         .         ?.         q.         .         .         /         Q/         /         /         /         :0         l0         0         0          1         F1         |1         1         1         ,2         c2         2         2         23         |3         3         3         4         @4         4         4         4         05         {5         5         5         &6         V6   0     6         6   8     6         %7   A     M7         7   H     7   O     7         8         78   X     Q8         8   `     8         8   g     8         39         l9         9         9         *:         j:         :         :         %;         b;         ;         ;         <         L<         <         <         <         =        3=   	     F=         z=         =         =         =         >>         >         >         >         +?         A?         }?         ?         ?         $@         V@         @         @         A         6A         pA         A         A         (B         ]B         B         B         ;C         C         C         C         D         JD         rD         D         D         *E         hE         E         E         F         \F         F         F         G         MG         G         G         G         2H         eH         H         H         I         YI         I         I         J         MJ         J         J         
K         >K         K         K         K         #L         VL         L         L         L         %M         \M         M         M         N         5N         dN         N         N         O         OO         O         O         P         DP         P         P         Q         4Q         sQ         Q         R         LR         R         R         R         /S         qS         S         S         T         7T         }T         T         T         "U         fU         U         U         V         MV         V         V         V         BW         W         W         W         <X         ~X         X         X         Y         DY         Y         Y         Y         /Z         rZ         Z         Z         [         B[         ~[         [         [         \         _\         \         \         \         %]         k]         ]         ]         ^         Q^         ^         ^         _         #_         `_         _         _         `         P`         `         `         `         =a         ja         a         a         a         b         ab         b         b         b         'c         mc         c         c         d         Pd         d         d         e         Te         e         e         f         Jf         f         f         f         #g         Rg         g         g         h         =h         ~h         h         h         )i         mi         i         i         j         _j         j         j          k         2k         ek         k         k         l         Bl         wl         l         l         ;m         jm         m         m         n         Nn         n         n         n         +o         `o         o         o         p         Up         p         p         q         Iq         q         q         q         r         ?r         sr         r         r         /s         ms         s         s         .t         ot         t         t         t          u         [u         u         u         v         Kv         v         v         w         Kw         aw         w         w         x         Wx         x         x         y         Ay         Py        ^y        hy         y         y         z   "     z         Gz         z   /     z         z         z         5{         I{   <     U{         {   E     {   Z     {         {   k     
|         ?|   v     Q|         w|         |         |        |         -}        >}         }        }         }        }         ~         &~        2~         \~         ~         ~        ~         ~                 ,         b                                             ]                             <       >       @             V                                             ,         c                                     S                                    O                                    P                                    K                                    X         u                           0         n                           %         n                                    ^                                    Y                                    "         T                                    D                                    7         k                                    A         s                           "         S        g                          
         J            #                       '         e                           7         l                           
         D         f        o                                                   2         l                                    ?                                             c                     
                       Y                           
         Q                                    ,         k                   D       D      D :     D W     D Y     $                            @       @                    Y       d   4  D d   4  D o   4  D o   4  D u   4  D {   4  D    4  D    4  D    4  $ d   [       e       n       s       x         @             o                   D      D      D       D!      $                    @                            D$      D%      D*      D+      D-      D.     D/     D0 '    D1 -    D2 ;    D3 A    D4 J    D6 M    D7 c    D9 l    D:     D;     D7     DA     DB     DC     DD     DF     DG     DH 	    DI     DJ (    DL -    DM 7    DN H    DO h    DQ     DR     DS     DD     DV     DW     $$        $    *   $    3   $    >   $    K  @ %    W   & ]  @ &    b  @ &     h   ' n  @ (    z       {      |         DZ      D[     D_     D` $    Da 0    Dc F    Dd [    Df d    Dg x    Di     Dj     Dl     Dn     Dd     Dr     Ds     Dt     $Z       Z       Z       Z      @ Z       [   @ \      @ \       \   @ ]                          R                                    #         ]         s  &      &w                       &	  H  ^  &	w H    &w      &w   ;bounds:/1137,224,128;\ superview:/190,352,32;subviews:/190,384,32;window:/190,416,32;\ vFlags:/1172,448,32;_vFlags:/1173,480,32;_gState:/11,512,32;\ _frameMatrix:/190,544,32;_drawMatrix:/190,576,32;\ _dragTypes:/1145,608,32;_vPrivate:/172,640,32;; _conFlags:T175=s4_RESERVED:4,0,11;_drawingAncestor:4,11,1;\ calcSize:4,12,1;ignoreMultiClick:4,13,1;editingValid:4,14,1;\ enabled:4,15,1;; Control:T176=s100isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;bounds:/1137,224,128;\ superview:/190,352,32;subviews:/190,384,32;window:/190,416,32;\ vFlags:/1172,448,32;_vFlags:/1173,480,32;_gState:/11,512,32;\ _frameMatrix:/190,544,32;_drawMatrix:/190,576,32;\ _dragTypes:/1145,608,32;_vPrivate:/172,640,32;tag:/11,672,32;\ cell:/190,704,32;conFlags:/1175,736,32;_reservedCshort1:/19,768,16;; Button:T177=s100isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;bounds:/1137,224,128;\ superview:/190,352,32;subviews:/190,384,32;window:/190,416,32;\ vFlags:/1172,448,32;_vFlags:/1173,480,32;_gState:/11,512,32;\ _frameMatrix:/190,544,32;_drawMatrix:/190,576,32;\ _dragTypes:/1145,608,32;_vPrivate:/172,640,32;tag:/11,672,32;\ cell:/190,704,32;conFlags:/1175,736,32;_reservedCshort1:/19,768,16;; _bmap:T178=s8normal:90,0,32;alternate:90,32,32;; _ke:T179=s8font:90,0,32;descent:12,32,32;; _icon:T180=u8bmap:178,0,64;ke:179,0,64;; _bcFlags1:T181=s4iconIsKeyEquivalent:4,0,1;iconSizeDiff:4,1,1;\ lastState:4,2,1;iconAndText:4,3,1;bottomOrLeft:4,4,1;\ horizontal:4,5,1;iconOverlaps:4,6,1;bordered:4,7,1;\ hasAlpha:4,8,1;lightByGray:4,9,1;lightByBackground:4,10,1;\ lightByContents:4,11,1;changeGray:4,12,1;\ changeBackground:4,13,1;changeContents:4,14,1;\ pushIn:4,15,1;; _bcFlags2:T182=s4_momentarySound:4,0,1;_inset:4,1,2;\ _RESERVED:4,3,4;transparent:4,7,1;keyEquivalent:4,8,8;; ButtonCell:T183=s72isa:/187,0,32;contents:/120,32,32;\ support:/190,64,32;cFlags1:/1138,96,32;cFlags2:/1139,128,32;\ _cFlags3:/1140,160,32;_reservedCshort:/19,192,16;\ tag:/11,224,32;target:/190,256,32;action:/191,288,32;\ _view:/190,320,32;altContents:/120,352,32;icon:/1180,384,64;\ sound:/190,448,32;bcFlags1:/1181,480,32;bcFlags2:/1182,512,32;\ periodicDelay:/19,544,16;periodicInterval:/19,560,16;; Panel:T184=s104isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;contentView:/190,224,32;\ delegate:/190,256,32;firstResponder:/190,288,32;\ lastLeftHit:/190,320,32;lastRightHit:/190,352,32;\ counterpart:/190,384,32;fieldEditor:/190,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1168,544,32;wFlags2:/1169,576,32;\ _borderView:/190,608,32;_displayDisabled:/18,640,16;\ _flushDisabled:/18,656,16;_cursorRects:/172,672,32;\ _trectTable:/1171,704,32;_invalidCursorView:/190,736,32;\ _miniIcon:/190,768,32;_private:/172,800,32;; ChoosePrinter:T185=s160isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;contentView:/190,224,32;\ delegate:/190,256,32;firstResponder:/190,288,32;\ lastLeftHit:/190,320,32;lastRightHit:/190,352,32;\ counterpart:/190,384,32;fieldEditor:/190,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1168,544,32;wFlags2:/1169,576,32;\ _borderView:/190,608,32;_displayDisabled:/18,640,16;\ _flushDisabled:/18,656,16;_cursorRects:/172,672,32;\ _trectTable:/1171,704,32;_invalidCursorView:/190,736,32;\ _miniIcon:/190,768,32;_private:/172,800,32;appIcon:/190,832,32;\ ok:/190,864,32;cancel:/190,896,32;border:/190,928,32;\ exitTag:/11,960,32;name:/190,992,32;type:/190,1024,32;\ note:/190,1056,32;_lastValues:/1186=*95,1088,32;accessoryView:/190,1120,32;\ _reservedChoosePrinter1:/14,1152,32;_reservedChoosePrinter2:/14,1184,32;\ _reservedChoosePrinter3:/14,1216,32;_reservedChoosePrinter4:/14,1248,32;; NXCharMetrics:Tt187=s32charCode:8,0,16;numKernPairs:11,16,8;\ reserved:11,24,8;xWidth:12,32,32;name:1,64,32;\ bbox:188=ar1;0;3;12,96,128;kernPairIndex:1,224,32;; NXLigature:Tt189=s12firstCharIndex:1,0,32;secondCharIndex:1,32,32;\ ligatureIndex:1,64,32;; NXEncodedLigature:Tt190=s4firstChar:11,0,8;secondChar:11,8,8;\ ligatureChar:11,16,8;reserved:11,24,8;; NXKernPair:Tt191=s12secondCharIndex:1,0,32;dx:12,32,32;\ dy:12,64,32;; NXKernXPair:Tt192=s8secondCharIndex:1,0,32;dx:12,32,32;; NXTrackKern:Tt193=s20degree:1,0,32;minPointSize:12,32,32;\ minKernAmount:12,64,32;maxPointSize:12,96,32;\ maxKernAmount:12,128,32;; NXCompositeChar:Tt194=s12compCharIndex:1,0,32;numParts:1,32,32;\ firstPartIndex:1,64,32;; NXCompositeCharPart:Tt195=s12partIndex:1,0,32;dx:12,32,32;\ dy:12,64,32;; _NXFontMetrics:T196=s164formatVersion:20,0,32;name:20,32,32;\ fullName:20,64,32;familyName:20,96,32;weight:20,128,32;\ italicAngle:12,160,32;isFixedPitch:2,192,8;isScreenFont:2,200,8;\ screenFontSize:8,208,16;fontBBox:188,224,128;underlinePosition:12,352,32;\ underlineThickness:12,384,32;version:20,416,32;\ notice:20,448,32;encodingScheme:20,480,32;capHeight:12,512,32;\ xHeight:12,544,32;ascender:12,576,32;descender:12,608,32;\ widths:197=*12,640,32;widthsLength:4,672,32;strings:20,704,32;\ stringsLength:4,736,32;hasYWidths:8,768,16;hasXYKerns:2,784,8;\ reserved:2,792,8;encoding:198=*8,800,32;yWidths:197,832,32;\ charMetrics:199=*187,864,32;numCharMetrics:1,896,32;\ ligatures:200=*189,928,32;numLigatures:1,960,32;\ encLigatures:201=*190,992,32;numEncLigatures:1,1024,32;\ kerns:202=u4kernPairs:203=*191,0,32;kernXPairs:204=*192,0,32;;,1056,32;\ numKernPairs:1,1088,32;trackKerns:205=*193,1120,32;\ numTrackKerns:1,1152,32;compositeChars:206=*194,1184,32;\ numCompositeChars:1,1216,32;compositeCharParts:207=*195,1248,32;\ numCompositeCharParts:1,1280,32;; NXFontMetrics:Tt196 NXFontTraitMask:t4 _fmFlags:T208=s4multipleFont:4,0,1;disabled:4,1,1;\ _RESERVED:4,2,14;; FontManager:T209=s52isa:/187,0,32;panel:/190,32,32;\ menu:/190,64,32;action:/191,96,32;whatToDo:/11,128,32;\ traitToChange:/14,160,32;selFont:/190,192,32;fmFlags:/1208,224,32;\ _lastPos:/19,256,16;delegate:/190,288,32;_reservedFMint2:/14,320,32;\ _reservedFMint3:/14,352,32;_reservedFMint4:/14,384,32;; _fpFlags:T210=s4multipleFont:4,0,1;dirty:4,1,1;\ _RESERVED:4,2,11;_amPreviewing:4,13,1;_alwaysPreview:4,14,1;\ _dontPreview:4,15,1;; FontPanel:T211=s192isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,128;contentView:/190,224,32;\ delegate:/190,256,32;firstResponder:/190,288,32;\ lastLeftHit:/190,320,32;lastRightHit:/190,352,32;\ counterpart:/190,384,32;fieldEditor:/190,416,32;\ winEventMask:/11,448,32;windowNum:/11,480,32;\ backgroundGray:/112,512,32;wFlags:/1168,544,32;wFlags2:/1169,576,32;\ _borderView:/190,608,32;_displayDisabled:/18,640,16;\ _flushDisabled:/18,656,16;_cursorRects:/172,672,32;\ _trectTable:/1171,704,32;_invalidCursorView:/190,736,32;\ _miniIcon:/190,768,32;_private:/172,800,32;faces:/190,832,32;\ families:/190,864,32;preview:/190,896,32;current:/190,928,32;\ size:/190,960,32;sizes:/190,992,32;manager:/190,1024,32;\ selFont:/190,1056,32;selMetrics:/1212=*196,1088,32;\ curTag:/11,1120,32;accessoryView:/190,1152,32;_keyBuffer:/120,1184,32;\ setButton:/190,1216,32;separator:/190,1248,32;sizeTitle:/190,1280,32;\ lastPreview:/120,1312,32;fpFlags:/1210,1344,32;_reservedFPshort1:/19,1376,16;\ _lastKeyTime:/13,1408,32;_chooser:/190,1440,32;_titles:/190,1472,32;\ _previewBox:/190,1504,32;; FormCell:T213=s60isa:/187,0,32;contents:/120,32,32;\ support:/190,64,32;cFlags1:/1138,96,32;cFlags2:/1139,128,32;\ _cFlags3:/1140,160,32;_reservedCshort:/19,192,16;\ tag:/11,224,32;target:/190,256,32;action:/191,288,32;\ _view:/190,320,32;titleWidth:/112,352,32;titleCell:/190,384,32;\ titleEndPoint:/112,416,32;_reservedFCint1:/14,448,32;; Listener:T214=s40isa:/187,0,32;portName:/120,32,32;\ listenPort:/11,64,32;signaturePort:/11,96,32;\ delegate:/190,128,32;timeout:/11,160,32;priority:/11,192,32;\ _delegate2:/190,224,32;_requestDelegate:/190,256,32;\ _reservedListener2:/11,288,32;; _menuFlags:T215=s4_changeTitle:4,0,1;_isServicesMenu:4,1,1;\ _templateType:4,2,2;_RESERVED:4,4,6;wasTornOff:4,10,1;\ wasAttached:4,11,1;tornOff:4,12,1;attached:4,13,1;\ autoupdate:4,14,1;sizeFitted:4,15,1;; Menu:T216=s132isa:/187,0,32;nextResponder:/190,32,32;\ _reserved:/190,64,32;frame:/1137,96,